import { Component, ContentChild, Directive, ElementRef, EventEmitter, Host, HostBinding, Input, NgModule, Output, ViewChild, ViewContainerRef, forwardRef, isDevMode } from '@angular/core';
import { FormControl, FormGroup, FormsModule, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validators } from '@angular/forms';
import { fromEvent as fromEvent$1 } from 'rxjs/observable/fromEvent';
import { map as map$1 } from 'rxjs/operators/map';
import { filter as filter$1 } from 'rxjs/operators/filter';
import { ToolBarButtonComponent, ToolBarComponent, ToolBarModule, ToolBarToolComponent } from '@progress/kendo-angular-toolbar';
import { DialogContentBase, DialogModule, DialogRef, DialogService } from '@progress/kendo-angular-dialog';
import { EditorView } from 'prosemirror-view';
import { autoJoin, baseKeymap, chainCommands, exitCode, setBlockType, toggleMark } from 'prosemirror-commands';
import { AllSelection, EditorState, NodeSelection, TextSelection } from 'prosemirror-state';
import { keymap } from 'prosemirror-keymap';
import { history, redo, undo } from 'prosemirror-history';
import { DOMParser, DOMSerializer, Fragment, Node, NodeRange, Schema, Slice } from 'prosemirror-model';
import { liftListItem, sinkListItem, splitListItem, wrapInList } from 'prosemirror-schema-list';
import { undoInputRule } from 'prosemirror-inputrules';
import { AddMarkStep, RemoveMarkStep, ReplaceAroundStep, liftTarget } from 'prosemirror-transform';
import { CommonModule } from '@angular/common';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { ButtonModule } from '@progress/kendo-angular-buttons';

/**
 * @hidden
 */
function outerWidth(element) {
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width += (parseFloat(style.marginLeft) || 0 + parseFloat(style.marginRight) || 0);
    return width;
}
/**
 * @hidden
 */
const serializeDOMAttrs = (el) => Array.from(el.attributes)
    .reduce((acc, curr) => Object.assign({}, acc, { [curr.name]: curr.value }), {});
/**
 * @hidden
 */
const removeEntries = (obj, predicate) => Object.keys(obj)
    .filter(key => predicate(key))
    .reduce((acc, curr) => Object.assign(acc, { [curr]: obj[curr] }), {});
/**
 * @hidden
 */
const removeEmptyEntries = (obj) => {
    const predicate = (key) => obj[key] !== null && obj[key] !== undefined && obj[key] !== '';
    return removeEntries(obj, predicate);
};
/**
 * @hidden
 */
const isEmpty = (obj) => Object.keys(obj).length === 0;
/**
 * @hidden
 */
const isNullOrUndefined = (value) => value === undefined || value === null;
/**
 * @hidden
 */
const isPresent = (value) => !isNullOrUndefined(value);
/**
 * @hidden
 */
const safeString = (value) => isNullOrUndefined(value) ? '' : value.toString();
/**
 * @hidden
 */
const first = (arr) => arr[0];
/**
 * @hidden
 */
const last = (arr) => arr[arr.length - 1];
/**
 * @hidden
 */
const unique = (arr) => Array.from(new Set(arr));
/**
 * @hidden
 */
const split = (splitter) => (value) => value.split(splitter);
/**
 * @hidden
 */
const trim = (value) => value.trim();
/**
 * @hidden
 */
const filter$2 = (predicate) => (arr) => arr.filter(predicate);

const SLOT = 0; //https://prosemirror.net/docs/guide/#schema.serialization_and_parsing
const commonAttributes = () => {
    return {
        class: { default: null },
        id: { default: null },
        style: { default: null }
    };
};
/**
 * @hidden
 */
const marks = {
    // :: MarkSpec A link. Has `href` and `title` attributes. `title`
    // defaults to an empty string. Rendered and parsed as an `<a>`
    // element.
    link: {
        attrs: {
            href: { default: '' },
            target: { default: null },
            title: { default: null }
        },
        inclusive: false,
        parseDOM: [{
                tag: 'a[href]',
                getAttrs: (dom) => ({
                    href: dom.getAttribute('href'),
                    target: dom.getAttribute('target'),
                    title: dom.getAttribute('title')
                })
            }],
        toDOM: (mark) => [
            'a',
            // Add default value for href. Otherwise the link is not rendered properly(blue with underline)
            Object.assign({}, { href: '' }, removeEmptyEntries(mark.attrs)),
            SLOT
        ]
    },
    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
    // Has parse rules that also match `<i>` and `font-style: italic`.
    em: {
        parseDOM: [
            { tag: 'i' },
            { tag: 'em' },
            { style: 'font-style=italic' }
        ],
        toDOM: () => ['em', SLOT]
    },
    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
    // also match `<b>` and `font-weight: bold`.
    strong: {
        parseDOM: [
            { tag: 'strong' },
            // This works around a Google Docs misbehavior where
            // pasted content will be inexplicably wrapped in `<b>`
            // tags with a font-weight normal `{tag: 'b', getAttrs: node => node.style.fontWeight != 'normal' && null}`,
            {
                style: 'font-weight',
                // According to the docs, the value can be a DOM element (for tag rules) or a string (for style rules).
                getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
            }
        ],
        toDOM: () => ['strong', SLOT]
    },
    // :: MarkSpec Code font mark. Represented as a `<code>` element.
    code: {
        parseDOM: [{ tag: 'code' }],
        toDOM: () => ['code', SLOT]
    },
    // :: MarkSpec An underline mark. Rendered as a `<u>` element.
    // Parse rules also match `text-decoration: underline`.
    underline: {
        parseDOM: [
            { tag: 'u' },
            { style: 'text-decoration=underline' }
        ],
        toDOM: () => ['u', SLOT]
    },
    // :: MarkSpec A strikethrough mark. Rendered as a `<del>` element.
    // Parse rules also match `<s>`, `<strike>`, `text-decoration: line-through`.
    strikethrough: {
        parseDOM: [
            { tag: 'del' },
            { tag: 's' },
            { tag: 'strike' },
            { style: 'text-decoration=line-through' }
        ],
        toDOM: () => ['del', SLOT]
    },
    // :: MarkSpec A subscript mark. Rendered as a `<sub>` element.
    // Parse rules also match `vertical-align: sub`.
    subscript: {
        parseDOM: [
            { tag: 'sub' },
            { style: 'vertical-align=sub' }
        ],
        toDOM: () => ['sub', SLOT]
    },
    // :: MarkSpec A superscript mark. Rendered as a `<sup>` element.
    // Parse rules also match `vertical-align: super`.
    superscript: {
        parseDOM: [
            { tag: 'sup' },
            { style: 'vertical-align=super' }
        ],
        toDOM: () => ['sup', SLOT]
    },
    style: {
        attrs: Object.assign({}, commonAttributes(), { style: {} }),
        parseDOM: [{
                tag: 'span[style]',
                // think about a way to remove span tags with empty style attributes or no style attributes at all
                getAttrs: (dom) => ({
                    style: dom.getAttribute('style')
                })
            }],
        toDOM: (mark) => [
            'span',
            Object.assign({}, removeEmptyEntries(mark.attrs)),
            SLOT
        ]
    }
};
/**
 * @hidden
 */
const nodes = {
    // :: NodeSpec The top level document node.
    doc: {
        content: 'block+'
    },
    // :: NodeSpec A plain textblock paragraph. Represented
    // as a `<p>` element in the DOM.
    paragraph: {
        content: 'inline*',
        group: 'block',
        attrs: Object.assign({}, commonAttributes()),
        parseDOM: [{
                tag: 'p',
                getAttrs: serializeDOMAttrs
            }],
        toDOM: (node) => isEmpty(node.attrs) ? ['p', SLOT] : ['p', removeEmptyEntries(node.attrs), SLOT]
    },
    // :: NodeSpec A blockquote (`<blockquote>`) which wraps one or more blocks.
    blockquote: {
        content: 'inline*',
        group: 'block',
        attrs: Object.assign({}, commonAttributes()),
        defining: true,
        parseDOM: [{ tag: 'blockquote' }],
        toDOM: (node) => ['blockquote', removeEmptyEntries(node.attrs), SLOT]
    },
    // :: NodeSpec A horizontal (`<hr>`) rule.
    horizontalRule: {
        group: 'block',
        parseDOM: [{ tag: 'hr' }],
        toDOM: () => ['hr']
    },
    // :: NodeSpec A heading textblock with a `level` attribute that
    // has to hold a number from 1 to 6. Parsed and serialized as an `<h1>` to
    // an `<h6>` element.
    heading: {
        attrs: Object.assign({ level: { default: 1 } }, commonAttributes()),
        content: 'inline*',
        group: 'block',
        defining: true,
        parseDOM: [
            { tag: 'h1', attrs: { level: 1 } },
            { tag: 'h2', attrs: { level: 2 } },
            { tag: 'h3', attrs: { level: 3 } },
            { tag: 'h4', attrs: { level: 4 } },
            { tag: 'h5', attrs: { level: 5 } },
            { tag: 'h6', attrs: { level: 6 } }
        ],
        toDOM: (node) => {
            const attrs = removeEntries(node.attrs, (key) => key !== 'level');
            return ['h' + node.attrs.level, removeEmptyEntries(attrs), SLOT];
        }
    },
    // :: NodeSpec A code listing. Prevents marks or non-text inline
    // nodes by default. Represented as a `<pre>` element with a
    // `<code>` element inside.
    codeBlock: {
        content: 'text*',
        marks: '',
        group: 'block',
        code: true,
        defining: true,
        parseDOM: [{
                tag: 'pre',
                preserveWhitespace: 'full'
            }],
        toDOM: () => ['pre', ['code', SLOT]]
    },
    // :: NodeSpec The text node.
    text: {
        group: 'inline'
    },
    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
    // `alt`, and `href` attributes. The last two default to an empty
    // string.
    image: {
        inline: true,
        attrs: Object.assign({}, commonAttributes(), { src: {}, alt: { default: null }, width: { default: null }, height: { default: null } }),
        group: 'inline',
        draggable: true,
        parseDOM: [{
                tag: 'img[src]',
                getAttrs: (dom) => ({
                    src: dom.getAttribute('src'),
                    alt: dom.getAttribute('alt'),
                    width: dom.getAttribute('width'),
                    height: dom.getAttribute('height')
                })
            }],
        toDOM: (node) => ['img', removeEmptyEntries(node.attrs)]
    },
    // :: NodeSpec A hard line break. Represented as a `<br>` element in the DOM.
    hardBreak: {
        inline: true,
        group: 'inline',
        selectable: false,
        parseDOM: [{ tag: 'br' }],
        toDOM: () => ['br']
    },
    // :: NodeSpec A list item. Represented as a `<li>` element.
    listItem: {
        attrs: Object.assign({}, commonAttributes()),
        content: 'paragraph block*',
        marks: '_',
        parseDOM: [{ tag: 'li' }],
        toDOM: (node) => ['li', removeEmptyEntries(node.attrs), SLOT]
    },
    // :: NodeSpec An ordered list. Represented as an `<ol>` element.
    // Has a single `order` attribute which determines the number at which
    // the list starts counting. Defaults to 1.
    orderedList: {
        attrs: {
            order: {
                default: 1
            }
        },
        content: 'listItem+',
        group: 'block',
        parseDOM: [{
                tag: 'ol',
                getAttrs: (dom) => ({
                    order: dom.hasAttribute('start') ? parseInt(dom.getAttribute('start'), 10) : 1
                })
            }],
        toDOM: node => (node.attrs.order === 1 ? ['ol', SLOT] : ['ol', { start: node.attrs.order }, SLOT])
    },
    // :: NodeSec An unordered list. Represented as a `<ul>` element.
    bulletList: {
        content: 'listItem+',
        group: 'block',
        parseDOM: [{ tag: 'ul' }],
        toDOM: () => ['ul', SLOT]
    }
};
/**
 * @hidden
 */
const schema = new Schema({
    marks,
    nodes
});

const mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
// https://github.com/ProseMirror/prosemirror-example-setup/blob/master/src/keymap.js
/**
 * @hidden
 */
function buildKeymap(schema, mapKeys) {
    let keys = {};
    function bind(key, cmd) {
        if (mapKeys) {
            let mapped = mapKeys[key];
            if (mapped === false) {
                return;
            }
            if (mapped) {
                key = mapped;
            }
        }
        keys[key] = cmd;
    }
    bind('Mod-z', undo);
    bind('Shift-Mod-z', redo);
    bind('Backspace', undoInputRule);
    if (!mac) {
        bind('Mod-y', redo);
    }
    if (schema.marks.strong) {
        bind('Mod-b', toggleMark(schema.marks.strong));
    }
    if (schema.marks.em) {
        bind('Mod-i', toggleMark(schema.marks.em));
    }
    if (schema.marks.underline) {
        bind('Mod-u', toggleMark(schema.marks.underline));
    }
    if (schema.nodes.hardBreak) {
        let br = schema.nodes.hardBreak, cmd = chainCommands(exitCode, (state, dispatch) => {
            dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
            return true;
        });
        bind('Mod-Enter', cmd);
        bind('Shift-Enter', cmd);
        if (mac) {
            bind('Ctrl-Enter', cmd);
        }
    }
    if (schema.nodes.listItem) {
        bind('Enter', splitListItem(schema.nodes.listItem));
    }
    return keys;
}

const style = (name, value) => {
    return { name: name, value: value };
};
/**
 * @hidden
 */
const alignLeftRules = [
    { node: 'paragraph', style: [style('text-align', 'left')] },
    { node: 'heading', style: [style('text-align', 'left')] },
    { node: 'listItem', style: [style('text-align', 'left'), style('list-style-position', 'inside')] }
];
/**
 * @hidden
 */
const alignRightRules = [
    { node: 'paragraph', style: [style('text-align', 'right')] },
    { node: 'heading', style: [style('text-align', 'right')] },
    { node: 'listItem', style: [style('text-align', 'right'), style('list-style-position', 'inside')] }
];
/**
 * @hidden
 */
const alignCenterRules = [
    { node: 'paragraph', style: [style('text-align', 'center')] },
    { node: 'heading', style: [style('text-align', 'center')] },
    { node: 'listItem', style: [style('text-align', 'center'), style('list-style-position', 'inside')] }
];
/**
 * @hidden
 */
const alignRemoveRules = [
    { node: 'paragraph', style: [style('text-align', '')] },
    { node: 'heading', style: [style('text-align', '')] },
    { node: 'listItem', style: [style('text-align', ''), style('list-style-position', '')] }
];

/**
 * @hidden
 */
const indentRules = [
    {
        node: 'paragraph',
        step: 30,
        style: 'margin-left',
        unit: 'px'
    }, {
        node: 'heading',
        step: 30,
        style: 'margin-left',
        unit: 'px'
    }
];
/**
 * @hidden
 */
const outdentRules = [
    {
        node: 'paragraph',
        step: -30,
        style: 'margin-left',
        unit: 'px'
    }, {
        node: 'heading',
        step: -30,
        style: 'margin-left',
        unit: 'px'
    }
];

const changeStyles = (elementStyle, newStyle) => {
    const styleToChange = newStyle.style;
    const regExp = newStyle.value;
    const newValue = newStyle.newValue;
    const styleMatches = [];
    if (elementStyle) {
        const splits = elementStyle.split(/\s*;\s*/).filter(s => s);
        const filtered = splits.filter(s => {
            if (!s.toLowerCase().trim().startsWith(styleToChange)) {
                return true;
            }
            const value = s.split(':')[1].trim();
            if (regExp.test(value)) {
                styleMatches.push(value);
                return false;
            }
            return true;
        });
        if (newValue) {
            filtered.push(`${styleToChange}: ${newValue}`);
        }
        return {
            style: filtered.join('; ') + (filtered.length ? ';' : ''),
            changed: !!newValue || filtered.length !== splits.length,
            styleMatches
        };
    }
    return { changed: false, styleMatches, style: null };
};
const changeStyleFromMark = (marks, toChange) => {
    const styleMark = marks.find(m => m.type.name === 'style');
    const elementStyle = styleMark && styleMark.attrs.style;
    return changeStyles(elementStyle, toChange);
};
const changeStyleMark = (tr, from, to, attrs, markType) => {
    const mark = markType.create({ style: attrs.style });
    let removed = [], added = [], removing = null, adding = null;
    tr.doc.nodesBetween(from, to, (node, pos, parent) => {
        if (!node.isInline) {
            return;
        }
        let marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
            const newStyle = changeStyleFromMark(marks, attrs);
            if (newStyle.changed || attrs.newValue) {
                const style = newStyle.changed ?
                    { style: newStyle.style } : { style: `${[attrs.style]}: ${attrs.newValue};` };
                const newStyleMark = markType.create(style);
                let newSet = newStyleMark.addToSet(marks);
                for (let i = 0; i < marks.length; i++) {
                    if (!marks[i].isInSet(newSet)) {
                        if (removing && removing.to === start && removing.mark.eq(marks[i])) {
                            removing.to = end;
                        }
                        else {
                            removing = new RemoveMarkStep(start, end, marks[i]);
                            removed.push(removing);
                        }
                    }
                }
                const previousAdded = adding && adding.to === start;
                const sameAdding = previousAdded &&
                    newStyleMark.attrs.style === adding.mark.attrs.style;
                if (previousAdded && sameAdding) {
                    adding.to = end;
                }
                else if (newStyleMark.attrs.style) {
                    adding = new AddMarkStep(start, end, newStyleMark);
                    added.push(adding);
                }
            }
        }
    });
    removed.forEach(s => tr.step(s));
    added.forEach(s => tr.step(s));
    return removed.length + added.length > 0;
};
const markApplies = (doc, ranges, type) => {
    let loop = i => {
        let ref = ranges[i];
        let $from = ref.$from;
        let $to = ref.$to;
        let can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, node => {
            if (can) {
                return false;
            }
            can = node.inlineContent && node.type.allowsMarkType(type);
        });
        if (can) {
            return { v: true };
        }
    };
    for (let i = 0; i < ranges.length; i++) {
        let returned = loop(i);
        if (returned) {
            return returned.v;
        }
    }
    return false;
};
/**
 * @hidden
 */
const changeStyle = (markType, attrs) => {
    return function (state, dispatch, tr) {
        let { empty, $cursor, ranges } = state.selection;
        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) {
            return false;
        }
        let result = false;
        if (dispatch) {
            tr = tr || state.tr;
            if ($cursor) {
                const currentMarks = state.storedMarks || $cursor.marks();
                if (markType.isInSet(currentMarks)) {
                    let newStyle = changeStyleFromMark(currentMarks, attrs);
                    dispatch(tr.removeStoredMark(markType));
                    dispatch(tr.addStoredMark(markType.create({ style: newStyle.style })));
                    result = true;
                }
            }
            else {
                for (let i = 0; i < ranges.length; i++) {
                    let { $from, $to } = ranges[i];
                    result = changeStyleMark(tr, $from.pos, $to.pos, attrs, markType);
                }
                if (result) {
                    tr.scrollIntoView();
                    dispatch(tr);
                }
            }
        }
        return result;
    };
};
const canChangeType = (stateDoc, pos, type) => {
    let $pos = stateDoc.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
};
/**
 * @hidden
 */
const changeBlockNode = (state, dispatch, tr, node, nodeType, attrs) => {
    let { from, to } = state.selection;
    let applicable = false;
    state.doc.nodesBetween(from, to, (currNode, pos) => {
        if (applicable) {
            return false;
        }
        if (!currNode.isTextblock || currNode.hasMarkup(nodeType, attrs)) {
            return;
        }
        if (currNode.type === nodeType) {
            applicable = true;
        }
        else {
            let $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
    });
    if (!applicable) {
        return false;
    }
    if (dispatch) {
        if (!nodeType.isTextblock) {
            throw new RangeError('Type given to setBlockType should be a textblock');
        }
        let mapFrom = tr.steps.length;
        tr.doc.nodesBetween(from, to, (currNode, pos) => {
            if (currNode.eq(node) && currNode.isTextblock && !currNode.hasMarkup(nodeType, attrs) &&
                canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), nodeType)) {
                // Ensure all markup that isn't allowed in the new node type is cleared
                tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), nodeType);
                let mapping = tr.mapping.slice(mapFrom);
                let startM = mapping.map(pos, 1), endM = mapping.map(pos + currNode.nodeSize, 1);
                let slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);
                tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));
                return false; // this will skip the node children
            }
        });
    }
    return true;
};
/**
 * @hidden
 */
function getMarkRange($cursor, markType) {
    const parentNode = $cursor.parent;
    const cursorNodeIndex = $cursor.index();
    const mark = parentNode.child(cursorNodeIndex).marks.find(m => m.type === markType);
    const childCount = parentNode.childCount;
    let start = $cursor.pos - $cursor.textOffset, end = parentNode.child(cursorNodeIndex).nodeSize, index, nodeSize;
    index = cursorNodeIndex - 1;
    while (index >= 0 && mark.isInSet(parentNode.child(index).marks)) {
        nodeSize = parentNode.child(index).nodeSize;
        end += nodeSize;
        start -= nodeSize;
        index -= 1;
    }
    index = cursorNodeIndex + 1;
    while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
        end += parentNode.child(index).nodeSize;
        index += 1;
    }
    return { from: start, to: start + end };
}
/**
 * @hidden
 */
const modifyMark = (markType, attrs) => (state, dispatch) => {
    const tr = state.tr;
    const { $cursor, from, to } = state.selection;
    if (!$cursor) {
        tr.doc.nodesBetween(from, to, (node, pos) => {
            if (node.isInline && markType.isInSet(node.marks)) {
                tr.removeMark(pos, pos + node.nodeSize, markType);
                tr.addMark(pos, pos + node.nodeSize, markType.create(attrs));
                dispatch(tr);
            }
        });
    }
    else {
        const parentNode = $cursor.parent;
        const cursorNodeIndex = $cursor.index();
        const mark = parentNode.child(cursorNodeIndex).marks.find(m => m.type === markType);
        const childCount = parentNode.childCount;
        let markStart = $cursor.pos - $cursor.textOffset, markSize = parentNode.child(cursorNodeIndex).nodeSize, index, nodeSize;
        index = cursorNodeIndex - 1;
        while (index >= 0 && mark && mark.isInSet(parentNode.child(index).marks)) {
            nodeSize = parentNode.child(index).nodeSize;
            markSize += nodeSize;
            markStart -= nodeSize;
            index -= 1;
        }
        index = cursorNodeIndex + 1;
        while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
            markSize += parentNode.child(index).nodeSize;
            index += 1;
        }
        tr.removeMark(markStart, markStart + markSize, markType);
        tr.addMark(markStart, markStart + markSize, markType.create(attrs));
        dispatch(tr);
    }
};
/**
 * @hidden
 */
const addStyles = (node, stylesToApply) => {
    let currentStyles = node.attrs.style, changedStyleResult = null, toChange = null;
    if (currentStyles) {
        stylesToApply.forEach(style => {
            toChange = { style: style.name, value: /^.+$/, newValue: style.value };
            changedStyleResult = changeStyles(currentStyles, toChange);
            currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;
        });
    }
    const reducer = (acc, curr) => (acc && curr.value ? acc + ' ' : '') + curr.value ? `${curr.name}: ${curr.value};` : '';
    currentStyles = currentStyles ||
        stylesToApply.reduce(reducer, '');
    return Object.assign({}, node.attrs, { style: currentStyles || null });
};

const { blockquote, bulletList, doc, heading, listItem, orderedList, paragraph, image } = schema.nodes;
const getTypeName = (n) => {
    return n instanceof Node ? n.type.name : n.name;
};
const isListType = (node) => {
    const nodeName = typeof node === 'string' ? node : getTypeName(node);
    return nodeName === getTypeName(orderedList) || nodeName === getTypeName(bulletList);
};
const getListTypeFromPos = (pos) => Array.from(new Array(pos.depth), (_, index) => pos.depth - index)
    .map((depth) => pos.node(depth))
    .map(getTypeName)
    .find(isListType);
const getNodeMarksOfType = (markType, n) => n.marks.filter(m => m.type.name === markType.name);
/**
 * @hidden
 */
const getUniqueStyleValues = (style, cssStyle) => {
    if (style.hasNodesWithoutMarks) {
        return '';
    }
    const uniqueMarkValues = style.marks
        .filter(m => m.type.name === 'style')
        .map((m) => m.attrs.style)
        .map(split(';'))
        .map(filter$2((m) => m.includes(cssStyle)))
        .map((cssStyleValues) => (cssStyleValues.length !== 0 ? cssStyleValues : [`${cssStyle}: INVALID`]))
        .map(first)
        .map(split(':'))
        .map(last)
        .map(trim)
        .reduce((acc, curr) => (acc.indexOf(curr) > -1 ? acc : [...acc, curr]), []);
    if (uniqueMarkValues.indexOf('INVALID') > -1 || uniqueMarkValues.length !== 1) {
        return '';
    }
    return uniqueMarkValues[0];
};
/**
 * @hidden
 */
function isMarkActive(state, markType) {
    const { from, $from, to, empty } = state.selection;
    if (empty) {
        return !!markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return !!state.doc.rangeHasMark(from, to, markType);
    }
}
/**
 * @hidden
 */
function isNodeActive(state, nodeType, attrs) {
    const parent = findParentNode((node) => getTypeName(node) === getTypeName(nodeType))(state.selection);
    if (!parent || (attrs && !Object.keys(attrs).length)) {
        return !!parent;
    }
    return parent.node.hasMarkup(nodeType, attrs);
}
/**
 * @hidden
 */
const isInListOfType = ({ selection }, nodeType) => {
    const { $anchor, $head } = selection;
    let topNodes = [];
    const anchorParentName = getListTypeFromPos($anchor);
    const headParentName = getListTypeFromPos($head);
    selection.content().content.descendants((n) => {
        topNodes = [...topNodes, n];
        return false;
    });
    const nonListTopNodes = topNodes.filter((n) => {
        return (getTypeName(n) !== getTypeName(bulletList)) && (getTypeName(n) !== getTypeName(orderedList));
    });
    // no selection
    if (selection instanceof TextSelection && selection.$cursor) {
        return getListTypeFromPos(selection.$cursor) === nodeType.name;
    }
    const hasSingleUniqueTopNode = unique(topNodes.map(getTypeName)).length === 1;
    // with selection
    if (nonListTopNodes.length > 0 || !hasSingleUniqueTopNode) {
        return false;
    }
    // from this point on we have guaranteed that the top nodes are all of the same LIST type
    // same top list node
    const node = first(topNodes);
    let listChildNodes = [getTypeName(node)];
    node.descendants((childNode) => {
        if (isListType(childNode)) {
            listChildNodes = [...listChildNodes, getTypeName(childNode)];
        }
    });
    if (last(listChildNodes) !== nodeType.name) {
        return false;
    }
    return anchorParentName === headParentName && anchorParentName === nodeType.name;
};
/**
 * @hidden
 */
const getActiveMarks = ({ selection }, markType) => {
    let hasNodesWithoutMarks = false;
    if (selection instanceof TextSelection && selection.$cursor) {
        return {
            marks: selection.$cursor.marks().filter(m => markType ? m.type.name === markType.name : true),
            hasNodesWithoutMarks
        };
    }
    const filtered = [];
    selection.content().content.descendants((n) => {
        if (n.type.name === 'text') {
            const nodeMarksOfType = markType ? getNodeMarksOfType(markType, n) : n.marks;
            if (n.marks.length > 0 && nodeMarksOfType.length > 0) {
                filtered.push(...nodeMarksOfType);
            }
            else {
                hasNodesWithoutMarks = true;
            }
        }
    });
    return {
        marks: filtered,
        hasNodesWithoutMarks
    };
};
/**
 * @hidden
 */
function activeNodeName(state) {
    let node;
    if (state.selection instanceof AllSelection) {
        node = state.doc;
    }
    else {
        const { $anchor } = state.selection;
        const blockNode = $anchor.node($anchor.blockRange().depth);
        const isDoc = getTypeName(blockNode) === getTypeName(doc);
        node = isDoc ? $anchor.node() : blockNode;
    }
    return {
        name: getTypeName(node),
        tag: getNodeTag(node)
    };
}
/**
 * @hidden
 */
function getNodeTag(node) {
    const parseRules = node.type.spec.parseDOM;
    const nodeAttrs = node.attrs;
    let parseRule;
    if (parseRules && parseRules.length) {
        if (parseRules.length === 1) {
            parseRule = parseRules[0];
        }
        else {
            parseRule = parseRules.find((rule) => {
                //TODO: refactor this
                return JSON.stringify(rule.attrs) === JSON.stringify(nodeAttrs);
            });
        }
    }
    if (parseRule) {
        return parseRule.tag;
    }
}
/**
 * @hidden
 */
function canIndent(state, nodeType) {
    return isNodeActive(state, nodeType) && sinkListItem(nodeType)(state);
}
/**
 * @hidden
 */
function canOutdent(state, nodeType) {
    const isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);
    const isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);
    return isNodeActive(state, nodeType) && (isNestedInOL || isNestedInUL) && liftListItem(nodeType)(state);
}
/**
 * @hidden
 */
function findParentNode(predicate) {
    return function (selection) {
        const { $from } = selection;
        for (let i = $from.depth; i > 0; i--) {
            const node = $from.node(i);
            if (predicate(node)) {
                return { depth: i, node };
            }
        }
    };
}
/**
 * @hidden
 */
function findNthParentNode(predicate, depth = 1) {
    return function (selection) {
        const { $from } = selection;
        for (let i = $from.depth; i > 0; i--) {
            const node = $from.node(i);
            if (predicate(node)) {
                depth = depth - 1;
                if (depth === 0) {
                    return { depth: i, node };
                }
            }
        }
    };
}
/**
 * @hidden
 */
function findNthParentNodeOfType(nodeType, depth = 1) {
    return function (selection) {
        return findNthParentNode((node) => getTypeName(node) === getTypeName(nodeType), depth)(selection);
    };
}
/**
 * @hidden
 */
const getMark = (state, markType) => {
    let { from, $from, to, empty } = state.selection;
    const stateDoc = state.doc;
    let mark;
    if (empty) {
        mark = markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        stateDoc.nodesBetween(from, to, node => {
            if (node.isInline && !mark) {
                mark = markType.isInSet(node.marks);
            }
        });
    }
    return mark;
};
/**
 * @hidden
 */
const getNodeFromSelection = (state) => {
    if (state.selection instanceof NodeSelection) {
        return state.selection.node;
    }
};
/**
 * @hidden
 */
const getSelectionText = (state) => {
    const sel = state.selection;
    if (sel instanceof TextSelection || sel instanceof AllSelection) {
        const fragment = sel.content().content;
        return fragment.textBetween(0, fragment.size);
    }
    return '';
};
/**
 * @hidden
 */
const removeMark = (markType) => (state, dispatch) => {
    const { from, to, $cursor } = state.selection;
    if ($cursor) {
        let resolvedRange = getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
};
/**
 * @hidden
 */
const toggleBold = toggleMark(schema.marks.strong);
/**
 * @hidden
 */
const toggleItalic = toggleMark(schema.marks.em);
/**
 * @hidden
 */
const toggleUnderline = toggleMark(schema.marks.underline);
/**
 * @hidden
 */
const toggleStrikethrough = toggleMark(schema.marks.strikethrough);
/**
 * @hidden
 */
const toggleSubscript = toggleMark(schema.marks.subscript);
/**
 * @hidden
 */
const toggleSuperscript = toggleMark(schema.marks.superscript);
/**
 * @hidden
 */
const setFontFamily = (font) => (state, dispatch) => {
    const marks = state.schema.marks;
    const cmd = changeStyle(marks.style, {
        style: 'font-family', value: /^.+$/, newValue: font
    });
    return cmd(state, dispatch);
};
/**
 * @hidden
 */
const setFontSize = (size) => (state, dispatch) => {
    const marks = state.schema.marks;
    const cmd = changeStyle(marks.style, {
        style: 'font-size', value: /^.+$/, newValue: `${size}px`
    });
    return cmd(state, dispatch);
};
/**
 * @hidden
 */
const createLink = (attrs) => (state, dispatch) => {
    if (isMarkActive(state, schema.marks.link)) {
        modifyMark(schema.marks.link, attrs)(state, dispatch);
    }
    else if (state.selection.empty) {
        if (isDevMode() && !isPresent(attrs.text)) {
            throw new Error("Unable to create link without text.Please pass a 'text' property as part of the parameter or select any text in the Editor.");
        }
        const newLink = schema.text(attrs.text, [
            schema.marks.link.create(attrs),
            ...getActiveMarks(state).marks
        ]);
        dispatch(state.tr.replaceSelectionWith(newLink, false));
    }
    else {
        toggleMark(schema.marks.link, attrs)(state, dispatch);
    }
};
/**
 * @hidden
 */
const applyHeading = (level) => setBlockType(heading, { level });
/**
 * @hidden
 */
const applyParagraph = setBlockType(paragraph);
/**
 * @hidden
 */
const applyBlockquote = setBlockType(blockquote);
/**
 * @hidden
 */
const format = ({ tag }) => {
    if (tag.match(/h\d\b/)) {
        return applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return applyParagraph;
    }
    else if (tag === 'blockquote') {
        return applyBlockquote;
    }
};
/**
 * @hidden
 */
const insertImage = (attrs) => (state, dispatch) => {
    const node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
};
/**
 * @hidden
 */
const getHTML = (state) => {
    const fragment = DOMSerializer
        .fromSchema(state.schema)
        .serializeFragment(state.doc.content);
    const element = document.createElement('div');
    element.appendChild(fragment);
    return element.innerHTML;
};
/**
 * @hidden
 */
const createContentNode = (value) => {
    const element = document.createElement('div');
    // when using ngModel with name attr, content is null and errors, default params dont help
    element.innerHTML = safeString(value).trim();
    return DOMParser.fromSchema(schema).parse(element);
};
/**
 * @hidden
 */
const setHTML = (content) => (state, dispatch) => dispatch(state.tr
    .setSelection(new AllSelection(state.doc))
    .replaceSelectionWith(createContentNode(content)));
/**
 * @hidden
 */
const hasSameMarkup = (dom1, dom2) => {
    const fragment1 = Fragment.from(createContentNode(dom1));
    const fragment2 = Fragment.from(createContentNode(dom2));
    return fragment1.eq(fragment2);
};
/**
 * @hidden
 * Checks if the selection contains a specific type of node.
 */
const hasNode = (state, nodeType) => {
    let { from, to } = state.selection;
    let result = false;
    state.doc.nodesBetween(from, to, node => {
        result = result || node.type === nodeType;
        return !result;
    });
    return result;
};
/**
 * @hidden
 */
const blockNodes = (state) => {
    const selection = state.selection;
    let { from, to, $from } = selection;
    const result = [];
    if (selection.node) {
        if (selection.node.isBlock) {
            result.push(selection.node);
        }
        else if ($from.parent && $from.parent.isBlock) {
            result.push($from.parent);
        }
    }
    else {
        state.doc.nodesBetween(from, to, node => {
            if (node.isBlock) {
                result.push(node);
            }
        });
    }
    return result;
};
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
const alignBlocks = (actions) => (state, dispatch) => {
    const blocks = blockNodes(state);
    const tr = state.tr;
    let result = false;
    blocks.forEach(node => {
        if (node.type.isTextblock) {
            let newAttrs = {};
            const action = actions.find(n => n.node === node.type.name);
            if (action) {
                newAttrs = addStyles(node, action.style);
            }
            result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
};
/**
 * @hidden
 * Checks if any block element in the selection is aligned.
 */
const isAligned = (state, actions) => {
    const blocks = blockNodes(state);
    let result = false;
    blocks.forEach(node => {
        if (!result && node.type.isTextblock && node.attrs.style) {
            const action = actions.find(a => a.node === node.type.name);
            if (action) {
                result = action.style.every(style => {
                    return !!style.value && new RegExp(`${style.name}:\\s?${style.value}`, 'i').test(node.attrs.style);
                });
            }
        }
    });
    return result;
};
/**
 * @hidden
 * Indenting block elements in the selection.
 *
 * @returns {boolean} - Returns true if any indentation is applied.
 */
const indentBlocks = (actions) => (state, dispatch) => {
    const blocks = blockNodes(state);
    const tr = state.tr;
    let result = false;
    blocks.forEach(node => {
        if (node.type.isTextblock) {
            let newAttrs;
            const action = actions.find(a => a.node === node.type.name);
            if (action) {
                const newStyle = {
                    name: action.style,
                    value: action.step > 0 ? `${action.step}${action.unit}` : ''
                };
                if (node.attrs.style) {
                    const re = new RegExp(`${action.style}:\\s?(\\d+)${action.unit}`, 'i');
                    const match = node.attrs.style.match(re);
                    if (match) {
                        let newMargin = parseFloat(match[1]) + action.step;
                        newMargin = newMargin <= 0 ? '' : newMargin;
                        newStyle.value = `${newMargin}${newMargin ? action.unit : ''}`;
                    }
                }
                newAttrs = addStyles(node, [newStyle]);
            }
            if (newAttrs) {
                result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
            }
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
};
/**
 * @hidden
 * Checks if any block element in the selection is indented.
 */
const isIndented = (state, actions) => {
    const blocks = blockNodes(state);
    let result = false;
    blocks.forEach(node => {
        if (!result && node.type.isTextblock && node.attrs.style) {
            const action = actions.find(a => a.node === node.type.name);
            if (action) {
                const reIndent = new RegExp(`${action.style}:\\s?\\d+${action.unit}`, 'i');
                result = reIndent.test(node.attrs.style);
            }
        }
    });
    return result;
};
/**
 * @hidden
 */
const canIndentAsListItem = (state) => sinkListItem(listItem)(state);
/**
 * @hidden
 */
const canOutdentAsListItem = (state) => liftListItem(listItem)(state);
/**
 * @hidden
 */
const canBeIndented = (state, rules) => {
    const nodes = state.schema.nodes;
    return (isIndented(state, rules) || indentRules.some(rule => nodes[rule.node] &&
        hasNode(state, nodes[rule.node]))) && !hasNode(state, listItem);
};
/**
 * @hidden
 */
const indent = (state, dispatch) => {
    const isIndentableBlock = canBeIndented(state, indentRules);
    if (canIndentAsListItem(state)) {
        sinkListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(indentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
const outdent = (state, dispatch) => {
    const isIndentableBlock = canBeIndented(state, outdentRules);
    if (canOutdentAsListItem(state)) {
        liftListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(outdentRules)(state, dispatch);
    }
};

/**
 * @hidden
 */
const rootListDepth = (pos, nodes) => {
    // Get the depth of the nearest ancestor list
    const { bulletList, orderedList, listItem } = nodes;
    let depth;
    for (let i = pos.depth - 1; i > 0; i--) {
        const node = pos.node(i);
        if (node.type === bulletList || node.type === orderedList) {
            depth = i;
        }
        if (node.type !== bulletList &&
            node.type !== orderedList &&
            node.type !== listItem) {
            break;
        }
    }
    return depth;
};
/**
 * @hidden
 */
const getListLiftTarget = (schema, resPos) => {
    // This will return (depth - 1) for root list parent of a list.
    let target = resPos.depth;
    const { bulletList, orderedList, listItem } = schema.nodes;
    for (let i = resPos.depth; i > 0; i--) {
        const node = resPos.node(i);
        if (node.type === bulletList || node.type === orderedList) {
            target = i;
        }
        if (node.type !== bulletList &&
            node.type !== orderedList &&
            node.type !== listItem) {
            break;
        }
    }
    return target - 1;
};
/**
 * @hidden
 */
function liftSelectionList(state, tr) {
    // The function will list paragraphs in selection out to level 1 below root list.
    const { from, to } = state.selection;
    const { paragraph } = state.schema.nodes;
    const listCol = [];
    tr.doc.nodesBetween(from, to, (node, pos) => {
        if (node.type === paragraph) {
            listCol.push({ node, pos });
        }
    });
    for (let i = listCol.length - 1; i >= 0; i--) {
        const paragr = listCol[i];
        const start = tr.doc.resolve(tr.mapping.map(paragr.pos));
        if (start.depth > 0) {
            let end;
            if (paragr.node.textContent && paragr.node.textContent.length > 0) {
                end = tr.doc.resolve(tr.mapping.map(paragr.pos + paragr.node.textContent.length));
            }
            else {
                end = tr.doc.resolve(tr.mapping.map(paragr.pos + 1));
            }
            const range = start.blockRange(end);
            if (range) {
                tr.lift(range, getListLiftTarget(state.schema, start));
            }
        }
    }
    return tr;
}
/**
 * @hidden
 */
const toggleList = (state, dispatch, view, listType) => {
    const { selection } = state;
    const fromNode = selection.$from.node(selection.$from.depth - 2);
    const endNode = selection.$to.node(selection.$to.depth - 2);
    if (!fromNode ||
        fromNode.type.name !== listType ||
        (!endNode || endNode.type.name !== listType)) {
        return toggleListCommand(listType)(state, dispatch, view);
    }
    else {
        const depth = rootListDepth(selection.$to, state.schema.nodes);
        let tr = liftFollowingList(state, selection.$to.pos, selection.$to.end(depth), depth, state.tr);
        tr = liftSelectionList(state, tr);
        dispatch(tr);
        return true;
    }
};
/**
 * @hidden
 */
function toggleListCommand(listType) {
    return function (state, dispatch, view) {
        if (!view) {
            return false;
        }
        state = view.state;
        const { $from, $to } = state.selection;
        const parent = $from.node(-2);
        const grandgrandParent = $from.node(-3);
        const isRangeOfSingleType = isRangeOfType(state.doc, $from, $to, state.schema.nodes[listType]);
        if (((parent && parent.type === state.schema.nodes[listType]) ||
            (grandgrandParent &&
                grandgrandParent.type === state.schema.nodes[listType])) &&
            isRangeOfSingleType) {
            // Untoggles list
            return liftListItems()(state, dispatch);
        }
        else {
            // Wraps selection in list and converts list type e.g. bullet_list -> ordered_list if needed
            if (!isRangeOfSingleType) {
                liftListItems()(state, dispatch);
                state = view.state;
            }
            return wrapInList$1(state.schema.nodes[listType])(state, dispatch);
        }
    };
}
/**
 * @hidden
 */
function liftListItem$1(state, selection, tr) {
    let { $from, $to } = selection;
    const nodeType = state.schema.nodes.listItem;
    let range = $from.blockRange($to, node => node.childCount && node.firstChild.type === nodeType);
    if (!range ||
        range.depth < 2 ||
        $from.node(range.depth - 1).type !== nodeType) {
        return tr;
    }
    let end = range.end;
    let endOfList = $to.end(range.depth);
    if (end < endOfList) {
        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(nodeType.create(undefined, range.parent.copy())), 1, 0), 1, true));
        range = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    return tr.lift(range, liftTarget(range)).scrollIntoView();
}
/**
 * @hidden
 */
function liftFollowingList(state, from, to, rootListDepthNum, tr) {
    // Function will lift list item following selection to level-1.
    const { listItem } = state.schema.nodes;
    let lifted = false;
    tr.doc.nodesBetween(from, to, (node, pos) => {
        if (!lifted && node.type === listItem && pos > from) {
            lifted = true;
            let listDepth = rootListDepthNum + 3;
            while (listDepth > rootListDepthNum + 2) {
                const start = tr.doc.resolve(tr.mapping.map(pos));
                listDepth = start.depth;
                const end = tr.doc.resolve(tr.mapping.map(pos + node.textContent.length));
                const sel = new TextSelection(start, end);
                tr = liftListItem$1(state, sel, tr);
            }
        }
    });
    return tr;
}
/**
 * @hidden
 */
function isRangeOfType(doc, $from, $to, nodeType) {
    // Step through block-nodes between $from and $to and returns false if a node is
    // found that isn't of the specified type
    return (getAncestorNodesBetween(doc, $from, $to).filter((node) => node.type !== nodeType).length === 0);
}
/**
 * @hidden
 */
function getAncestorNodesBetween(doc, $from, $to) {
    // Returns all top-level ancestor-nodes between $from and $to
    const nodes = Array();
    const maxDepth = findAncestorPosition(doc, $from).depth;
    let current = doc.resolve($from.start(maxDepth));
    while (current.pos <= $to.start($to.depth)) {
        const depth = Math.min(current.depth, maxDepth);
        const node = current.node(depth);
        if (node) {
            nodes.push(node);
        }
        if (depth === 0) {
            break;
        }
        let next = doc.resolve(current.after(depth));
        if (next.start(depth) >= doc.nodeSize - 2) {
            break;
        }
        if (next.depth !== current.depth) {
            next = doc.resolve(next.pos + 2);
        }
        if (next.depth) {
            current = doc.resolve(next.start(next.depth));
        }
        else {
            current = doc.resolve(next.end(next.depth));
        }
    }
    return nodes;
}
/**
 * @hidden
 */
function findAncestorPosition(doc, pos) {
    // Traverse the document until an "ancestor" is found. Any nestable block can be an ancestor.
    const nestableBlocks = ['blockquote', 'bulletList', 'orderedList'];
    if (pos.depth === 1) {
        return pos;
    }
    let node = pos.node(pos.depth);
    let newPos = pos;
    while (pos.depth >= 1) {
        pos = doc.resolve(pos.before(pos.depth));
        node = pos.node(pos.depth);
        if (node && nestableBlocks.indexOf(node.type.name) !== -1) {
            newPos = pos;
        }
    }
    return newPos;
}
/**
 * @hidden
 */
function liftListItems() {
    return function (state, dispatch) {
        const { tr } = state;
        const { $from, $to } = state.selection;
        tr.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
            // Following condition will ensure that block types paragraph, heading, codeBlock, blockquote, panel are lifted.
            // isTextblock is true for paragraph, heading, codeBlock.
            if (node.isTextblock ||
                node.type.name === 'blockquote' ||
                node.type.name === 'panel') {
                const sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));
                const range = sel.$from.blockRange(sel.$to);
                if (!range || sel.$from.parent.type !== state.schema.nodes.listItem) {
                    return false;
                }
                const target = range && liftTarget(range);
                if (target === undefined || target === null) {
                    return false;
                }
                tr.lift(range, target);
            }
        });
        if (dispatch) {
            dispatch(tr);
        }
        return true;
    };
}
/**
 * @hidden
 */
function wrapInList$1(nodeType) {
    return autoJoin(wrapInList(nodeType), (before, after) => before.type === after.type && before.type === nodeType);
}
/**
 * @hidden
 */
function toggleUnorderedList(state, dispatch, view) {
    return toggleList(state, dispatch, view, 'bulletList');
}
/**
 * @hidden
 */
function toggleOrderedList(state, dispatch, view) {
    return toggleList(state, dispatch, view, 'orderedList');
}

const inlineCommand = {
    bold: () => toggleBold,
    italic: () => toggleItalic,
    createLink: (attr) => createLink(attr),
    unlink: () => removeMark(schema.marks.link),
    underline: () => toggleUnderline,
    strikethrough: () => toggleStrikethrough,
    fontSize: (size) => setFontSize(size),
    fontFamily: (font) => setFontFamily(font),
    subscript: () => toggleSubscript,
    superscript: () => toggleSuperscript,
    insertFile: (attr) => createLink(attr)
};
const blockCommand = {
    format: (formatAttr) => format(formatAttr),
    alignLeft: () => alignBlocks(alignLeftRules),
    alignCenter: () => alignBlocks(alignCenterRules),
    alignRight: () => alignBlocks(alignRightRules),
    alignJustify: () => alignBlocks(alignRemoveRules),
    indent: () => indent,
    outdent: () => outdent,
    // think about changing the command name.
    insertOrderedList: () => toggleOrderedList,
    // think about changing the command name.
    insertUnorderedList: () => toggleUnorderedList,
    getHTML: () => getHTML,
    setHTML: (content) => setHTML(content),
    undo: () => undo,
    redo: () => redo,
    insertImage: (attrs) => insertImage(attrs)
};
/**
 * @hidden
 */
const editorCommands = Object.assign({}, inlineCommand, blockCommand);

// import { EditorService } from '../editor.service';
/**
 * @hidden
 */
class SourceDialogComponent extends DialogContentBase {
    constructor(dialog) {
        super(dialog);
        this.dialog = dialog;
        this.data = '';
    }
    onCancelAction() {
        this.dialog.close();
    }
    onConfirmAction() {
        this.editor.exec('setHTML', this.getData());
        this.dialog.close();
        this.editor.focus();
    }
    getData() {
        return this.textarea.nativeElement.value;
    }
    setData() {
        this.data = this.indent(this.editor.getSource());
    }
    indent(content) {
        return content.replace(/<\/(p|li|ul|ol|h[1-6]|table|tr|td|th)>/ig, "</$1>\n")
            .replace(/<(ul|ol)([^>]*)><li/ig, "<$1$2>\n<li")
            .replace(/<br \/>/ig, "<br />\n")
            .replace(/\n$/, "");
    }
}
SourceDialogComponent.decorators = [
    { type: Component, args: [{
                template: `
        <kendo-dialog-titlebar>
            View Source
        </kendo-dialog-titlebar>
        <textarea [value]="data" #textarea class="k-editor-textarea k-input"></textarea>
        <kendo-dialog-actions>
            <button kendoButton (click)="onCancelAction()">Cancel</button>
            <button kendoButton (click)="onConfirmAction()" [primary]="true">Update</button>
        </kendo-dialog-actions>
    `,
                styles: [`
        >>> .k-editor-textarea {
            height: 100%;
        }
    `]
            },] },
];
/** @nocollapse */
SourceDialogComponent.ctorParameters = () => [
    { type: DialogRef, },
];
SourceDialogComponent.propDecorators = {
    'editor': [{ type: Input },],
    'textarea': [{ type: ViewChild, args: ['textarea',] },],
};

/**
 * @hidden
 */
class ImageDialogComponent extends DialogContentBase {
    constructor(dialog) {
        super(dialog);
        this.dialog = dialog;
        this.src = new FormControl('', Validators.required);
        this.alt = new FormControl('');
        this.width = new FormControl('', Validators.min(1));
        this.height = new FormControl('', Validators.min(1));
        this.data = {
            src: '',
            alt: '',
            width: '',
            height: ''
        };
        this.imageData = new FormGroup({
            src: this.src,
            alt: this.alt,
            width: this.width,
            height: this.height
        });
    }
    onCancelAction() {
        this.dialog.close();
    }
    onConfirmAction() {
        if (this.src.value) {
            this.editor.exec('insertImage', this.getData());
            this.dialog.close();
            this.editor.focus();
        }
    }
    setData(state) {
        const node = getNodeFromSelection(state);
        if (node) {
            this.src.patchValue(node.attrs.src);
            this.alt.patchValue(node.attrs.alt);
            this.width.patchValue(node.attrs.width);
            this.height.patchValue(node.attrs.height);
        }
    }
    getData() {
        return {
            src: this.src.value,
            alt: this.alt.value,
            width: this.normalizeDimension(this.width.value),
            height: this.normalizeDimension(this.height.value)
        };
    }
    normalizeDimension(value) {
        return Number.isNaN(parseInt(value, 10)) || parseInt(value, 10) <= 0 ? '' : safeString(parseInt(value, 10));
    }
}
ImageDialogComponent.decorators = [
    { type: Component, args: [{
                template: `
        <kendo-dialog-titlebar>
            Insert Image
        </kendo-dialog-titlebar>
        <div class="k-editor-dialog">
            <div class="k-editor-dialog k-popup-edit-form k-window-content k-content" >
                <div class="k-edit-form-container k-window-content">
                    <div class="k-edit-label">
                        <label for="k-editor-image-url">Web address</label>
                    </div>
                    <div class="k-edit-field">
                        <input [formControl]="src" type="text" class="k-input k-textbox">
                    </div>
                    <div class="k-edit-label">
                        <label for="k-editor-image-text">Alternate text</label>
                    </div>
                    <div class="k-edit-field">
                        <input [formControl]="alt" type="text" class="k-input k-textbox">
                    </div>
                    <div class="k-edit-label">
                        <label for="k-editor-image-width">Width (px)</label>
                    </div>
                    <div class="k-edit-field">
                        <input [formControl]="width" type="text" class="k-input k-textbox">
                    </div>
                    <div class="k-edit-label">
                        <label for="k-editor-image-height">Height (px)</label>
                    </div>
                    <div class="k-edit-field">
                        <input [formControl]="height" type="text" class="k-input k-textbox">
                    </div>
                </div>
            </div>
        </div>
        <kendo-dialog-actions>
            <button kendoButton (click)="onCancelAction()">Cancel</button>
            <button kendoButton [disabled]="imageData.invalid" (click)="onConfirmAction()" [primary]="true">Insert</button>
        </kendo-dialog-actions>
    `
            },] },
];
/** @nocollapse */
ImageDialogComponent.ctorParameters = () => [
    { type: DialogRef, },
];
ImageDialogComponent.propDecorators = {
    'editor': [{ type: Input },],
};

/**
 * @hidden
 */
class FileLinkDialogComponent extends DialogContentBase {
    constructor(dialog) {
        super(dialog);
        this.dialog = dialog;
        this.linkForm = new FormGroup({
            'href': new FormControl('', Validators.required),
            'text': new FormControl('', Validators.required),
            'title': new FormControl('')
        });
    }
    onCancelAction() {
        this.dialog.close();
    }
    onConfirmAction() {
        const linkData = this.getData();
        this.editor.exec(this.command, linkData);
        this.dialog.close();
        this.editor.focus();
    }
    get titleText() {
        return this.command === 'createLink' ? 'Insert Link' : 'Insert File';
    }
    setData(state) {
        if (this.command === 'createLink') {
            this.linkForm.addControl('target', new FormControl());
        }
        const linkMark = getMark(state, schema.marks.link);
        if (linkMark) {
            // const linkMarkRange = getMarkRange(state.selection.$cursor, schema.marks.link);
            // const mark = parentNode.child(cursorNodeIndex).marks.find(m => m.type === markType);
            this.linkForm.reset({
                href: linkMark.attrs.href,
                title: linkMark.attrs.title,
                target: isPresent(linkMark.attrs.target),
                text: this.setLinkText(state)
            });
            return;
        }
        if (!state.selection.empty) {
            this.linkForm.patchValue({
                'text': getSelectionText(state)
            });
        }
    }
    setLinkText(state) {
        const selection = state.selection;
        if (selection.empty && selection.$cursor) {
            const cursor = selection.$cursor;
            const cursorNodeIndex = cursor.index();
            const parentNode = cursor.parent;
            return parentNode.child(cursorNodeIndex).text;
        }
        else {
            return getSelectionText(state);
        }
    }
    getData() {
        let linkData = this.linkForm.value;
        if (isPresent(this.linkForm.controls.target)) {
            linkData.target = linkData.target ? '_blank' : null;
        }
        return linkData;
    }
}
FileLinkDialogComponent.decorators = [
    { type: Component, args: [{
                template: `
        <kendo-dialog-titlebar>
            {{ titleText }}
        </kendo-dialog-titlebar>
        <div class='k-editor-dialog'>
            <div class='k-editor-dialog k-popup-edit-form k-window-content k-content'>
                <div class='k-edit-form-container k-window-content'>
                    <form novalidate [formGroup]='linkForm'>
                        <div class='k-edit-label'>
                            <label (click)='hrefInput.focus()'>Web address</label>
                        </div>
                        <div class='k-edit-field'>
                            <input #hrefInput formControlName='href' type='text' class='k-input k-textbox'>
                        </div>

                        <div class='k-edit-label'>
                            <label (click)='textInput.focus()'>Text</label>
                        </div>
                        <div class='k-edit-field'>
                            <input #textInput formControlName='text' type='text' class='k-input k-textbox'>
                        </div>

                        <div class='k-edit-label'>
                            <label (click)='titleInput.focus()'>Title</label>
                        </div>
                        <div class='k-edit-field'>
                            <input #titleInput formControlName='title' type='text' class='k-input k-textbox'>
                        </div>
                        <ng-container *ngIf="command === 'createLink'">
                            <div class='k-edit-label'></div>
                            <div>
                                <input type='checkbox' id='k-target-blank' class='k-checkbox' formControlName='target'>
                                <label class='k-checkbox-label' for='k-target-blank'>Open Link in new window</label>
                            </div>
                        </ng-container>
                    </form>
                </div>
            </div>
        </div>
        <kendo-dialog-actions>
            <button kendoButton (click)='onCancelAction()'>Cancel</button>
            <button kendoButton [disabled]='linkForm.invalid' (click)='onConfirmAction()' [primary]='true'>Insert</button>
        </kendo-dialog-actions>
    `
            },] },
];
/** @nocollapse */
FileLinkDialogComponent.ctorParameters = () => [
    { type: DialogRef, },
];
FileLinkDialogComponent.propDecorators = {
    'editor': [{ type: Input },],
    'command': [{ type: Input },],
};

// Disabling this allows for getting inferred types for each item
// tslint:disable-next-line:typedef
function updateToolBar({ state }) {
    return {
        //marks
        bold: isMarkActive(state, schema.marks.strong),
        italic: isMarkActive(state, schema.marks.em),
        underline: isMarkActive(state, schema.marks.underline),
        strikethrough: isMarkActive(state, schema.marks.strikethrough),
        unlink: !isMarkActive(state, schema.marks.link),
        subscript: isMarkActive(state, schema.marks.subscript),
        superscript: isMarkActive(state, schema.marks.superscript),
        style: getActiveMarks(state, schema.marks.style),
        //nodes
        format: activeNodeName(state),
        insertOrderedList: isInListOfType(state, schema.nodes.orderedList),
        insertUnorderedList: isInListOfType(state, schema.nodes.bulletList),
        indent: canIndent(state, schema.nodes.listItem) || canBeIndented(state, indentRules),
        outdent: canOutdent(state, schema.nodes.listItem) || canBeIndented(state, outdentRules),
        alignLeft: isAligned(state, alignLeftRules),
        alignCenter: isAligned(state, alignCenterRules),
        alignRight: isAligned(state, alignRightRules),
        alignJustify: isAligned(state, alignRemoveRules),
        //history
        undo: !undo(state),
        redo: !redo(state),
        //selection
        noSelection: state.selection.empty
    };
}
const EMPTY_PARAGRAPH = '<p></p>';
/**
 * Represents the [Kendo UI Editor component for Angular]({% slug overview_editor %}).
 */
class EditorComponent {
    constructor(element, dialogService) {
        this.element = element;
        this.dialogService = dialogService;
        /**
         * Fires each time the value of the Editor is changed upon user interaction&mdash;
         * for example, when the component is blurred or the value is updated through the `viewSource` dialog.
         * When the value of the Editor is programmatically changed through its API (`ngModel`) or form binding (`formControl`),
         * the `valueChange` event is not triggered because it might cause a mix-up with the
         * built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.stateChange = new EventEmitter();
        this.onChangeCallback = (_) => { }; // tslint:disable-line:no-empty
        this.onTouchedCallback = (_) => { }; // tslint:disable-line:no-empty
    }
    /**
     * Sets the value of the Editor ([see example]({% slug overview_editor %}#toc-basic-usage)).
     */
    set value(value) {
        this._value = value;
        this._previousValue = value;
        if (this.view) {
            this.exec('setHTML', this._value);
        }
    }
    get value() {
        let value = this.view ? this.getSource() : this._value;
        if (value === EMPTY_PARAGRAPH) {
            return this._value ? '' : this._value;
        }
        else {
            return value;
        }
    }
    get className() {
        return 'k-widget k-editor';
    }
    ngAfterViewInit() {
        const that = this;
        const containerNativeElement = this.container.element.nativeElement;
        const contentNode = createContentNode(this.value);
        const state = EditorState.create({
            schema: schema,
            doc: contentNode,
            plugins: [
                history(),
                keymap(buildKeymap(schema)),
                keymap({
                    'Mod-z': undo,
                    'Mod-y': redo
                }),
                keymap(baseKeymap)
            ]
        });
        this.view = new EditorView(containerNativeElement, {
            state,
            dispatchTransaction: function (tr) {
                // `this` is bound to the view instance.
                this.updateState(this.state.apply(tr));
                that.stateChange.emit(updateToolBar(this));
                // When the user utilizes keyboard shortcuts&mdash;for example, `Ctrl`+`b`&mdash;
                // `tr.docChanged` is `true` and the toolbar is not updated.
                // A possible future solution is to move the keymaps to the service.
                // if (!tr.docChanged) {
                //     that.stateChange.emit(updateToolBar(that.view));
                // }
            }
        });
        this.subs = fromEvent$1(this.container.element.nativeElement, 'keyup').pipe(map$1((e) => e.keyCode), filter$1((code) => code === 121), // F10
        map$1(() => this.userToolBar || this.defaultToolbar))
            .subscribe((toolbar) => toolbar.nativeElement.focus());
        const blur$ = fromEvent$1(this.element.nativeElement, 'focusout').pipe(filter$1((event) => !this.element.nativeElement.contains(event.relatedTarget)));
        this.subs.add(
        //on blur & new value
        blur$.pipe(map$1(() => this.value), filter$1((value) => !hasSameMarkup(value, that._previousValue)))
            .subscribe((value) => {
            this._previousValue = value;
            this.onChangeCallback(value);
            this.valueChange.emit(value);
        }));
        this.subs.add(
        //on every blur
        blur$.subscribe(() => this.onTouchedCallback()));
    }
    /**
     * Executes a command on the currently selected text.
     *
     * @param {EditorCommand} commandName - The command that will be executed.
     * @param {any} attr - Optional parameters for the command. Apart from the following list,
     * the parameters do not expect specific attributes when you call them:
     * - `format` - Accepts an object with the `tag` property.
     * The supported tags are `p`, `blockquote`, and any of the `h1` to `h6` heading tags.
     * - `createLink` - Accepts an object with the `href`, `title`, and `target` properties. The `href` property is mandatory.
     * - `setHTML` - Accepts a `string` parameter.
     *
     * @example
     * ```ts-no-run
     * // Toggles the bold styling.
     * editor.exec('bold');
     *
     * // Creates a bullet list.
     * editor.exec('insertUnorderedList');
     *
     * // Creates a link.
     * editor.exec('createLink', { href: 'www.progress.com', title: 'Progress', target: 'window' });
     *
     * // Changes the format of a text block.
     * editor.exec('format', { tag: 'h2' });
     *
     * // Changes the content of the Editor.
     * editor.exec('setHTML', '<p>HTML content</p>');
     * ```
     */
    exec(commandName, attr) {
        // Finds a command and applies the attributes.
        const command = editorCommands[commandName](attr);
        // Executes a ProseMirror command.
        command(this.view.state, this.view.dispatch, this.view);
        // See the `dispatchTransaction` comments.
        // this.stateChange.emit(updateToolBar(this.view));
    }
    /**
     * Opens a dialog.
     * @param {DialogCommand} dialogName - The name of the dialog that will open.
     *
     * The supported values are:
     * * `createLink`
     * * `viewSource`
     * * `insertFile`
     * * `insertImage`
     *
     * @example
     * ```ts-no-run
     * // Opens a `createLink` dialog.
     * editor.openDialog('createLink');
     *
     * // Opens a `viewSource` dialog.
     * editor.exec('viewSource');
     * ```
     */
    openDialog(dialogName) {
        const editorDialogs = {
            createLink: {
                content: FileLinkDialogComponent
            },
            insertFile: {
                content: FileLinkDialogComponent
            },
            insertImage: {
                content: ImageDialogComponent
            },
            viewSource: {
                content: SourceDialogComponent,
                height: 400,
                width: 500
            }
        };
        const dialog = Object.assign({ appendTo: this.dialogContainer }, editorDialogs[dialogName]);
        const dialogContent = this.dialogService.open(dialog).content.instance;
        if (dialogName === 'createLink' || dialogName === 'insertFile') {
            dialogContent.command = dialogName;
        }
        dialogContent.editor = this;
        dialogContent.setData(this.view.state);
    }
    /**
     * Manually focus the Editor.
     */
    focus() {
        this.view.focus();
    }
    /**
     * Manually blur the Editor.
     */
    blur() {
        this.view.dom.blur();
    }
    /**
     * @hidden
     */
    getSource() {
        return getHTML(this.view.state);
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        // To avoid confusion, non-existent values are always undefined.
        this.value = value === null ? undefined : value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
}
EditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'kendo-editor',
                providers: [
                    DialogService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => EditorComponent),
                        multi: true
                    }
                ],
                template: `
        <ng-content select="kendo-toolbar"></ng-content>
        <kendo-toolbar *ngIf="!userToolBar" #defaultToolbar>
            <kendo-toolbar-buttongroup>
                <kendo-toolbar-button kendoEditorBoldButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorItalicButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorUnderlineButton></kendo-toolbar-button>
            </kendo-toolbar-buttongroup>
            <kendo-toolbar-dropdownlist kendoEditorFormat></kendo-toolbar-dropdownlist>
            <kendo-toolbar-buttongroup>
                <kendo-toolbar-button kendoEditorAlignLeftButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorAlignCenterButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorAlignRightButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorAlignJustifyButton></kendo-toolbar-button>
            </kendo-toolbar-buttongroup>
            <kendo-toolbar-buttongroup>
                <kendo-toolbar-button kendoEditorInsertUnorderedListButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorInsertOrderedListButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorIndentButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorOutdentButton></kendo-toolbar-button>
            </kendo-toolbar-buttongroup>
            <kendo-toolbar-buttongroup>
                <kendo-toolbar-button kendoEditorCreateLinkButton></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorUnlinkButton></kendo-toolbar-button>
            </kendo-toolbar-buttongroup>
            <kendo-toolbar-button kendoEditorInsertImageButton></kendo-toolbar-button>
        </kendo-toolbar>
        <div #content class="k-content" style="height: 300px;"></div>

        <ng-container #dialogsContainer></ng-container>
    `,
                styles: [`
        >>> .k-content > .ProseMirror {
            height: 100%;
            width: 100%;
            box-sizing: border-box;
            outline: none;
            overflow: auto;
        }
    `]
            },] },
];
/** @nocollapse */
EditorComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DialogService, },
];
EditorComponent.propDecorators = {
    'value': [{ type: Input },],
    'valueChange': [{ type: Output },],
    'className': [{ type: HostBinding, args: ['class',] },],
    'userToolBar': [{ type: ContentChild, args: [ToolBarComponent, { read: ElementRef },] },],
    'dialogContainer': [{ type: ViewChild, args: ["dialogsContainer", { read: ViewContainerRef },] },],
    'container': [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] },],
    'defaultToolbar': [{ type: ViewChild, args: ['defaultToolbar', { read: ElementRef },] },],
};

/**
 * A component which configures an existing `DropDownListComponent` as an Editor tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The component associates a `kendo-dropdownlist` with an Editor command that changes the format of a content block and
 * automatically defines the options of the drop-down list and sets its values.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-dropdownlist kendoEditorFormat></kendo-toolbar-dropdownlist>
 * ```
 */
class EditorFormatComponent extends ToolBarToolComponent {
    constructor(editor) {
        super();
        this.editor = editor;
        /**
         * Fires when the user updates the value of the drop-down list.
         */
        this.valueChange = new EventEmitter();
    }
    ngOnInit() {
        this.itemDisabled = (itemArgs) => {
            return itemArgs.dataItem.tag === null;
        };
        this.data = [
            { text: 'Paragraph', tag: 'p' },
            { text: 'Quotation', tag: 'blockquote' },
            { text: 'Heading 1', tag: 'h1' },
            { text: 'Heading 2', tag: 'h2' },
            { text: 'Heading 3', tag: 'h3' },
            { text: 'Heading 4', tag: 'h4' },
            { text: 'Heading 5', tag: 'h5' },
            { text: 'Heading 6', tag: 'h6' }
        ];
        this.defaultItem = { text: 'Format', tag: null };
        this.subs = this.editor.stateChange.subscribe(({ format }) => {
            const index = this.data.findIndex(item => item.tag === format.tag);
            this.value = index !== -1 ? format.tag : null;
        });
    }
    /**
     * @hidden
     */
    onValueChange(ev) {
        if (isPresent(ev)) {
            this.editor.exec('format', { tag: ev });
            this.editor.focus();
        }
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    get outerWidth() {
        if (this.element) {
            return outerWidth(this.element.nativeElement);
        }
    }
}
EditorFormatComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:no-forward-ref
                providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => EditorFormatComponent) }],
                selector: 'kendo-toolbar-dropdownlist[kendoEditorFormat]',
                template: `
        <ng-template #toolbarTemplate>
            <kendo-dropdownlist
                #element
                [defaultItem]="defaultItem"
                [textField]="'text'"
                [valueField]="'tag'"
                [data]="data"
                [(value)]="value"
                [valuePrimitive]="true"
                [itemDisabled]="itemDisabled"
                (valueChange)="onValueChange($event)"
            >
                <ng-template kendoDropDownListItemTemplate let-dataItem>
                    <ng-container [ngSwitch]="dataItem.tag">
                        <span *ngSwitchCase="'h1'" style="display: block; font-size: 2em; margin-left: 0; font-weight: bold;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchCase="'h2'" style="display: block; font-size: 1.5em; margin-left: 0; font-weight: bold;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchCase="'h3'" style="display: block; font-size: 1.17em; margin-left: 0; font-weight: bold;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchCase="'h4'" style="display: block; font-size: 1em; margin-left: 0; font-weight: bold;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchCase="'h5'" style="display: block; font-size: .83em; margin-left: 0; font-weight: bold;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchCase="'h6'" style="display: block; font-size: .67em; margin-left: 0; font-weight: bold;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchCase="'p'" style="display: block; margin-left: 0;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchCase="'blockquote'" style="display: block; margin-left: 0;">
                            {{ dataItem.text }}
                        </span>

                        <span *ngSwitchDefault>{{ dataItem.text }}</span>
                    </ng-container>
                </ng-template>
            </kendo-dropdownlist>
        </ng-template>
    `
            },] },
];
/** @nocollapse */
EditorFormatComponent.ctorParameters = () => [
    { type: EditorComponent, decorators: [{ type: Host },] },
];
EditorFormatComponent.propDecorators = {
    'valueChange': [{ type: Output },],
    'toolbarTemplate': [{ type: ViewChild, args: ['toolbarTemplate',] },],
    'element': [{ type: ViewChild, args: ['element',] },],
};

/**
 * A component which configures an existing `DropDownListComponent` as an Editor tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The component associates a `kendo-dropdownlist` with an Editor command that changes the font size of a content block and
 * automatically defines the options of the drop-down list and sets its values.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-dropdownlist kendoEditorFontSize></kendo-toolbar-dropdownlist>
 * ```
 */
class EditorFontSizeComponent extends ToolBarToolComponent {
    constructor(editor) {
        super();
        this.editor = editor;
        /**
         * Fires when the user updates the value of the drop-down list.
         */
        this.valueChange = new EventEmitter();
    }
    ngOnInit() {
        this.itemDisabled = itemArgs => {
            return itemArgs.dataItem.size === null;
        };
        this.data = [
            { text: '8px', size: '8' },
            { text: '10px', size: '10' },
            { text: '12px', size: '12' },
            { text: '14px', size: '14' },
            { text: '18px', size: '18' },
            { text: '24px', size: '24' },
            { text: '36px', size: '36' }
        ];
        this.defaultItem = { text: 'Font size', size: null };
        this.subs = this.editor.stateChange.subscribe(({ style }) => {
            // remove units(px, em, rem...)
            // string#match returns array
            this.value = (getUniqueStyleValues(style, 'font-size').match(/\d+/g) || [null])[0];
        });
    }
    /**
     * @hidden
     */
    onValueChange(ev) {
        if (isPresent(ev)) {
            this.editor.exec('fontSize', ev);
            this.editor.focus();
        }
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    get outerWidth() {
        if (this.element) {
            return outerWidth(this.element.nativeElement);
        }
    }
}
EditorFontSizeComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:no-forward-ref
                providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => EditorFontSizeComponent) }],
                selector: 'kendo-toolbar-dropdownlist[kendoEditorFontSize]',
                template: `
        <ng-template #toolbarTemplate>
            <kendo-dropdownlist
                #element
                [defaultItem]="defaultItem"
                [textField]="'text'"
                [valueField]="'size'"
                [data]="data"
                [(value)]="value"
                [valuePrimitive]="true"
                [itemDisabled]="itemDisabled"
                (valueChange)="onValueChange($event)"
            >
            </kendo-dropdownlist>
        </ng-template>
    `
            },] },
];
/** @nocollapse */
EditorFontSizeComponent.ctorParameters = () => [
    { type: EditorComponent, decorators: [{ type: Host },] },
];
EditorFontSizeComponent.propDecorators = {
    'valueChange': [{ type: Output },],
    'toolbarTemplate': [{ type: ViewChild, args: ['toolbarTemplate',] },],
    'element': [{ type: ViewChild, args: ['element',] },],
};

/**
 * A component which configures an existing `DropDownListComponent` as an Editor tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The component associates a `kendo-toolbar-dropdownlist` with an Editor command that changes the font family of a content block and
 * automatically defines the options of the drop-down list and sets its values.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-dropdownlist kendoEditorFontFamily></kendo-toolbar-dropdownlist>
 * ```
 */
class EditorFontFamilyComponent extends ToolBarToolComponent {
    constructor(editor) {
        super();
        this.editor = editor;
        /**
         * Overrides the default font list.
         *
         */
        this.fonts = [
            { text: 'Arial', fontName: 'Arial,"Helvetica Neue",Helvetica,sans-serif' },
            { text: 'Courier New', fontName: '"Courier New",Courier,"Lucida Sans Typewriter","Lucida Typewriter",monospace' },
            { text: 'Georgia', fontName: 'Georgia,Times,"Times New Roman",serif' },
            {
                text: 'Impact',
                fontName: 'Impact,Haettenschweiler,"Franklin Gothic Bold",Charcoal,"Helvetica Inserat","Bitstream Vera Sans Bold","Arial Black","sans serif"'
            },
            { text: 'Lucida Console', fontName: '"Lucida Console","Lucida Sans Typewriter",monaco,"Bitstream Vera Sans Mono",monospace' },
            { text: 'Tahoma', fontName: 'Tahoma,Verdana,Segoe,sans-serif' },
            { text: 'Times New Roman', fontName: 'TimesNewRoman,"Times New Roman",Times,Baskerville,Georgia,serif' },
            { text: 'Trebuchet MS', fontName: '"Trebuchet MS","Lucida Grande","Lucida Sans Unicode","Lucida Sans",Tahoma,sans-serif' },
            { text: 'Verdana', fontName: 'Verdana,Geneva,sans-serif' }
        ];
        /**
         * Fires when the user updates the value of the drop-down list.
         */
        this.valueChange = new EventEmitter();
    }
    ngOnInit() {
        this.itemDisabled = (itemArgs) => {
            return itemArgs.dataItem.fontName === null;
        };
        this.defaultItem = { text: 'Font name', fontName: null };
        this.subs = this.editor.stateChange.subscribe(({ style }) => {
            this.value = getUniqueStyleValues(style, 'font-family') || null;
        });
    }
    /**
     * @hidden
     */
    onValueChange(ev) {
        if (isPresent(ev)) {
            this.editor.exec('fontFamily', ev);
            this.editor.focus();
        }
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    get outerWidth() {
        if (this.element) {
            return outerWidth(this.element.nativeElement);
        }
    }
}
EditorFontFamilyComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:no-forward-ref
                providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => EditorFontFamilyComponent) }],
                selector: 'kendo-toolbar-dropdownlist[kendoEditorFontFamily]',
                template: `
        <ng-template #toolbarTemplate>
            <kendo-dropdownlist
                #element
                [defaultItem]="defaultItem"
                [textField]="'text'"
                [valueField]="'fontName'"
                [data]="fonts"
                [(value)]="value"
                [valuePrimitive]="true"
                [itemDisabled]="itemDisabled"
                (valueChange)="onValueChange($event)"
            >
                <ng-template kendoDropDownListItemTemplate let-dataItem>
                    <span [ngStyle]="{ 'font-family': dataItem.fontName }">
                        {{ dataItem.text }}
                    </span>
                </ng-template>
            </kendo-dropdownlist>
        </ng-template>
    `
            },] },
];
/** @nocollapse */
EditorFontFamilyComponent.ctorParameters = () => [
    { type: EditorComponent, decorators: [{ type: Host },] },
];
EditorFontFamilyComponent.propDecorators = {
    'fonts': [{ type: Input },],
    'valueChange': [{ type: Output },],
    'toolbarTemplate': [{ type: ViewChild, args: ['toolbarTemplate',] },],
    'element': [{ type: ViewChild, args: ['element',] },],
};

/**
 * @hidden
 */
const commandIcons = {
    bold: 'bold',
    italic: 'italic',
    underline: 'underline',
    strikethrough: 'strikethrough',
    createLink: 'link-horizontal',
    unlink: 'unlink-horizontal',
    insertOrderedList: 'list-ordered',
    insertUnorderedList: 'list-unordered',
    indent: 'indent-increase',
    outdent: 'indent-decrease',
    alignLeft: 'align-left',
    alignCenter: 'align-center',
    alignRight: 'align-right',
    alignJustify: 'align-justify',
    viewSource: 'html',
    undo: 'undo',
    redo: 'redo',
    insertFile: 'file-add',
    insertImage: 'image',
    subscript: 'sub-script',
    superscript: 'sup-script'
};

/**
 * @hidden
 */
class EditorCommandButton {
    constructor(command, button, editor) {
        this.command = command;
        this.button = button;
        this.editor = editor;
    }
    ngOnInit() {
        if (!this.button.icon) {
            this.button.icon = commandIcons[this.command];
        }
        this.subs = this.button.click.subscribe(() => {
            this.editor.exec(this.command);
            this.editor.focus();
        });
        this.subs.add(this.editor.stateChange.subscribe(this.onStateChange.bind(this)));
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    // tslint:disable-next-line:typedef
    onStateChange(toolBarState) {
        this.button.selected = toolBarState[this.command];
    }
}

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignLeft tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignLeftButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignLeftButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorAlignLeftButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('alignLeft', button, editor);
    }
}
EditorAlignLeftButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorAlignLeftButton]'
            },] },
];
/** @nocollapse */
EditorAlignLeftButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignCenter tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignCenterButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignCenterButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorAlignCenterButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('alignCenter', button, editor);
    }
}
EditorAlignCenterButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorAlignCenterButton]'
            },] },
];
/** @nocollapse */
EditorAlignCenterButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignRight tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignRightButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignRightButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorAlignRightButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('alignRight', button, editor);
    }
}
EditorAlignRightButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorAlignRightButton]'
            },] },
];
/** @nocollapse */
EditorAlignRightButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignJustify tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignJustifyButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignJustifyButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorAlignJustifyButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('alignJustify', button, editor);
    }
}
EditorAlignJustifyButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorAlignJustifyButton]'
            },] },
];
/** @nocollapse */
EditorAlignJustifyButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Redo tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorRedoButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorRedoButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorRedoButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('redo', button, editor);
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    onStateChange(toolBarState) {
        this.button.disabled = toolBarState[this.command];
    }
}
EditorRedoButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorRedoButton]'
            },] },
];
/** @nocollapse */
EditorRedoButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Undo tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUndoButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUndoButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorUndoButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('undo', button, editor);
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    onStateChange(toolBarState) {
        this.button.disabled = toolBarState[this.command];
    }
}
EditorUndoButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorUndoButton]'
            },] },
];
/** @nocollapse */
EditorUndoButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * @hidden
 */
class EditorCommandDialog {
    constructor(dialog, button, editor) {
        this.dialog = dialog;
        this.button = button;
        this.editor = editor;
    }
    ngOnInit() {
        if (!this.button.icon) {
            this.button.icon = commandIcons[this.dialog];
        }
        this.subs = this.button.click.subscribe(() => {
            this.editor.openDialog(this.dialog);
        });
        this.subs.add(this.editor.stateChange.subscribe(this.onStateChange.bind(this)));
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    onStateChange(_toolBarState) { }
}

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor InsertImage tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertImageButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertImageButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorInsertImageButtonDirective extends EditorCommandDialog {
    constructor(button, editor) {
        super('insertImage', button, editor);
    }
}
EditorInsertImageButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorInsertImageButton]'
            },] },
];
/** @nocollapse */
EditorInsertImageButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Indent tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorIndentButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorIndentButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorIndentButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('indent', button, editor);
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    onStateChange(toolBarState) {
        this.button.disabled = !toolBarState[this.command];
    }
}
EditorIndentButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorIndentButton]'
            },] },
];
/** @nocollapse */
EditorIndentButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Outdent tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorOutdentButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorOutdentButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorOutdentButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('outdent', button, editor);
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    onStateChange(toolBarState) {
        this.button.disabled = !toolBarState[this.command];
    }
}
EditorOutdentButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorOutdentButton]'
            },] },
];
/** @nocollapse */
EditorOutdentButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor CreateLink tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorCreateLinkButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorCreateLinkButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorCreateLinkButtonDirective extends EditorCommandDialog {
    constructor(button, editor) {
        super('createLink', button, editor);
    }
}
EditorCreateLinkButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorCreateLinkButton]'
            },] },
];
/** @nocollapse */
EditorCreateLinkButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Unlink tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnlinkButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnlinkButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorUnlinkButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('unlink', button, editor);
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    onStateChange(toolBarState) {
        this.button.disabled = toolBarState.unlink;
    }
}
EditorUnlinkButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorUnlinkButton]'
            },] },
];
/** @nocollapse */
EditorUnlinkButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor InsertOrderedList tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertOrderedListButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertOrderedListButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorInsertOrderedListButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('insertOrderedList', button, editor);
    }
}
EditorInsertOrderedListButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorInsertOrderedListButton]'
            },] },
];
/** @nocollapse */
EditorInsertOrderedListButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor InsertUnorderedList tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertUnorderedListButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertUnorderedListButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorInsertUnorderedListButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('insertUnorderedList', button, editor);
    }
}
EditorInsertUnorderedListButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorInsertUnorderedListButton]'
            },] },
];
/** @nocollapse */
EditorInsertUnorderedListButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor ViewSource tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorViewSourceButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorViewSourceButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorViewSourceButtonDirective extends EditorCommandDialog {
    constructor(button, editor) {
        super('viewSource', button, editor);
    }
}
EditorViewSourceButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorViewSourceButton]'
            },] },
];
/** @nocollapse */
EditorViewSourceButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Bold tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorBoldButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorBoldButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorBoldButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('bold', button, editor);
    }
}
EditorBoldButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorBoldButton]'
            },] },
];
/** @nocollapse */
EditorBoldButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Italic tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorItalicButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorItalicButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorItalicButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('italic', button, editor);
    }
}
EditorItalicButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorItalicButton]'
            },] },
];
/** @nocollapse */
EditorItalicButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Underline tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnderlineButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnderlineButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorUnderlineButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('underline', button, editor);
    }
}
EditorUnderlineButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorUnderlineButton]'
            },] },
];
/** @nocollapse */
EditorUnderlineButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Strikethrough tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorStrikethroughButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorStrikethroughButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorStrikethroughButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('strikethrough', button, editor);
    }
}
EditorStrikethroughButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorStrikethroughButton]'
            },] },
];
/** @nocollapse */
EditorStrikethroughButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Subscript tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSubscriptButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSubscriptButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorSubscriptButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('subscript', button, editor);
    }
}
EditorSubscriptButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorSubscriptButton]'
            },] },
];
/** @nocollapse */
EditorSubscriptButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Superscript tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSuperscriptButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSuperscriptButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
class EditorSuperscriptButtonDirective extends EditorCommandButton {
    constructor(button, editor) {
        super('superscript', button, editor);
    }
}
EditorSuperscriptButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorSuperscriptButton]'
            },] },
];
/** @nocollapse */
EditorSuperscriptButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor 'Insert File' tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertFileButton></kendo-toolbar-button>
 * ```
 */
class EditorInsertFileButtonDirective extends EditorCommandDialog {
    constructor(button, editor) {
        super('insertFile', button, editor);
    }
}
EditorInsertFileButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'kendo-toolbar-button[kendoEditorInsertFileButton]'
            },] },
];
/** @nocollapse */
EditorInsertFileButtonDirective.ctorParameters = () => [
    { type: ToolBarButtonComponent, },
    { type: EditorComponent, decorators: [{ type: Host },] },
];

const COMPONENT_DIRECTIVES = [
    //alignment
    EditorAlignLeftButtonDirective,
    EditorAlignCenterButtonDirective,
    EditorAlignRightButtonDirective,
    EditorAlignJustifyButtonDirective,
    //file
    EditorInsertFileButtonDirective,
    //history
    EditorRedoButtonDirective,
    EditorUndoButtonDirective,
    //image
    EditorInsertImageButtonDirective,
    //indent
    EditorIndentButtonDirective,
    EditorOutdentButtonDirective,
    //link
    EditorCreateLinkButtonDirective,
    EditorUnlinkButtonDirective,
    //list
    EditorInsertOrderedListButtonDirective,
    EditorInsertUnorderedListButtonDirective,
    //source
    EditorViewSourceButtonDirective,
    //typographical emphasis
    EditorBoldButtonDirective,
    EditorItalicButtonDirective,
    EditorUnderlineButtonDirective,
    EditorStrikethroughButtonDirective,
    EditorSubscriptButtonDirective,
    EditorSuperscriptButtonDirective
];
const TOOLBAR_TOOLS = [
    EditorFontSizeComponent,
    EditorFontFamilyComponent,
    EditorFormatComponent
];
const TOOLBAR_DIALOGS = [
    FileLinkDialogComponent,
    ImageDialogComponent,
    SourceDialogComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the Editor component.
 *
 * The package exports:
 * - `EditorComponent`&mdash;The `EditorComponent` class.
 * - `EditorButtonDirective`&mdash;The `EditorButton` directive class.
 * - `EditorDropDownDirective`&mdash;The `EditorDropDown` directive class.
 * - `EditorDialogDirective`&mdash;The `EditorDialog` directive class.
 * - `ToolBarDropDownListComponent`&mdash;The `ToolBarDropDownListComponent` directive class.
 * - `ButtonModule`&mdash;The `KendoButton` module.
 * - `ToolBarModule`&mdash;The `KendoToolBar` module.
 *
 *  * @example
 *
 * ```ts-no-run
 * // Import the Editor module
 * import { EditorModule } from '@progress/kendo-angular-editor';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare the app component
 *     imports:      [BrowserModule, EditorModule], // import the Editor module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class EditorModule {
}
EditorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    EditorComponent,
                    COMPONENT_DIRECTIVES,
                    TOOLBAR_TOOLS,
                    TOOLBAR_DIALOGS
                ],
                entryComponents: [
                    TOOLBAR_DIALOGS
                ],
                exports: [
                    EditorComponent,
                    COMPONENT_DIRECTIVES,
                    TOOLBAR_TOOLS,
                    ToolBarModule,
                    ButtonModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                imports: [
                    CommonModule,
                    ToolBarModule,
                    DropDownsModule,
                    DialogModule,
                    ButtonModule,
                    FormsModule,
                    ReactiveFormsModule
                ]
            },] },
];
/** @nocollapse */
EditorModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { FileLinkDialogComponent, ImageDialogComponent, SourceDialogComponent, EditorAlignCenterButtonDirective, EditorAlignJustifyButtonDirective, EditorAlignLeftButtonDirective, EditorAlignRightButtonDirective, EditorFontFamilyComponent, EditorFontSizeComponent, EditorFormatComponent, EditorRedoButtonDirective, EditorUndoButtonDirective, EditorInsertImageButtonDirective, EditorIndentButtonDirective, EditorOutdentButtonDirective, EditorCreateLinkButtonDirective, EditorInsertFileButtonDirective, EditorUnlinkButtonDirective, EditorInsertOrderedListButtonDirective, EditorInsertUnorderedListButtonDirective, EditorCommandButton, EditorCommandDialog, EditorViewSourceButtonDirective, EditorBoldButtonDirective, EditorItalicButtonDirective, EditorStrikethroughButtonDirective, EditorSubscriptButtonDirective, EditorSuperscriptButtonDirective, EditorUnderlineButtonDirective, EditorComponent, EditorModule };
