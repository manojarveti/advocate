"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var prosemirror_model_1 = require("prosemirror-model");
var prosemirror_state_1 = require("prosemirror-state");
var prosemirror_commands_1 = require("prosemirror-commands");
var prosemirror_schema_list_1 = require("prosemirror-schema-list");
var schema_1 = require("./config/schema");
var util_1 = require("./util");
var indent_rules_1 = require("./config/indent-rules");
var prosemirror_core_utils_1 = require("./prosemirror-core-utils");
var _a = schema_1.schema.nodes, blockquote = _a.blockquote, bulletList = _a.bulletList, doc = _a.doc, heading = _a.heading, listItem = _a.listItem, orderedList = _a.orderedList, paragraph = _a.paragraph, image = _a.image;
var getTypeName = function (n) {
    return n instanceof prosemirror_model_1.Node ? n.type.name : n.name;
};
var isListType = function (node) {
    var nodeName = typeof node === 'string' ? node : getTypeName(node);
    return nodeName === getTypeName(orderedList) || nodeName === getTypeName(bulletList);
};
var getListTypeFromPos = function (pos) {
    return Array.from(new Array(pos.depth), function (_, index) { return pos.depth - index; })
        .map(function (depth) { return pos.node(depth); })
        .map(getTypeName)
        .find(isListType);
};
var getNodeMarksOfType = function (markType, n) { return n.marks.filter(function (m) { return m.type.name === markType.name; }); };
/**
 * @hidden
 */
exports.getUniqueStyleValues = function (style, cssStyle) {
    if (style.hasNodesWithoutMarks) {
        return '';
    }
    var uniqueMarkValues = style.marks
        .filter(function (m) { return m.type.name === 'style'; })
        .map(function (m) { return m.attrs.style; })
        .map(util_1.split(';'))
        .map(util_1.filter(function (m) { return m.includes(cssStyle); }))
        .map(function (cssStyleValues) { return (cssStyleValues.length !== 0 ? cssStyleValues : [cssStyle + ": INVALID"]); })
        .map(util_1.first)
        .map(util_1.split(':'))
        .map(util_1.last)
        .map(util_1.trim)
        .reduce(function (acc, curr) { return (acc.indexOf(curr) > -1 ? acc : acc.concat([curr])); }, []);
    if (uniqueMarkValues.indexOf('INVALID') > -1 || uniqueMarkValues.length !== 1) {
        return '';
    }
    return uniqueMarkValues[0];
};
/**
 * @hidden
 */
function isMarkActive(state, markType) {
    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
    if (empty) {
        return !!markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return !!state.doc.rangeHasMark(from, to, markType);
    }
}
exports.isMarkActive = isMarkActive;
/**
 * @hidden
 */
function isNodeActive(state, nodeType, attrs) {
    var parent = findParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); })(state.selection);
    if (!parent || (attrs && !Object.keys(attrs).length)) {
        return !!parent;
    }
    return parent.node.hasMarkup(nodeType, attrs);
}
exports.isNodeActive = isNodeActive;
/**
 * @hidden
 */
exports.isInListOfType = function (_a, nodeType) {
    var selection = _a.selection;
    var $anchor = selection.$anchor, $head = selection.$head;
    var topNodes = [];
    var anchorParentName = getListTypeFromPos($anchor);
    var headParentName = getListTypeFromPos($head);
    selection.content().content.descendants(function (n) {
        topNodes = topNodes.concat([n]);
        return false;
    });
    var nonListTopNodes = topNodes.filter(function (n) {
        return (getTypeName(n) !== getTypeName(bulletList)) && (getTypeName(n) !== getTypeName(orderedList));
    });
    // no selection
    if (selection instanceof prosemirror_state_1.TextSelection && selection.$cursor) {
        return getListTypeFromPos(selection.$cursor) === nodeType.name;
    }
    var hasSingleUniqueTopNode = util_1.unique(topNodes.map(getTypeName)).length === 1;
    // with selection
    if (nonListTopNodes.length > 0 || !hasSingleUniqueTopNode) {
        return false;
    }
    // from this point on we have guaranteed that the top nodes are all of the same LIST type
    // same top list node
    var node = util_1.first(topNodes);
    var listChildNodes = [getTypeName(node)];
    node.descendants(function (childNode) {
        if (isListType(childNode)) {
            listChildNodes = listChildNodes.concat([getTypeName(childNode)]);
        }
    });
    if (util_1.last(listChildNodes) !== nodeType.name) {
        return false;
    }
    return anchorParentName === headParentName && anchorParentName === nodeType.name;
};
/**
 * @hidden
 */
exports.getActiveMarks = function (_a, markType) {
    var selection = _a.selection;
    var hasNodesWithoutMarks = false;
    if (selection instanceof prosemirror_state_1.TextSelection && selection.$cursor) {
        return {
            marks: selection.$cursor.marks().filter(function (m) { return markType ? m.type.name === markType.name : true; }),
            hasNodesWithoutMarks: hasNodesWithoutMarks
        };
    }
    var filtered = [];
    selection.content().content.descendants(function (n) {
        if (n.type.name === 'text') {
            var nodeMarksOfType = markType ? getNodeMarksOfType(markType, n) : n.marks;
            if (n.marks.length > 0 && nodeMarksOfType.length > 0) {
                filtered.push.apply(filtered, nodeMarksOfType);
            }
            else {
                hasNodesWithoutMarks = true;
            }
        }
    });
    return {
        marks: filtered,
        hasNodesWithoutMarks: hasNodesWithoutMarks
    };
};
/**
 * @hidden
 */
function activeNodeName(state) {
    var node;
    if (state.selection instanceof prosemirror_state_1.AllSelection) {
        node = state.doc;
    }
    else {
        var $anchor = state.selection.$anchor;
        var blockNode = $anchor.node($anchor.blockRange().depth);
        var isDoc = getTypeName(blockNode) === getTypeName(doc);
        node = isDoc ? $anchor.node() : blockNode;
    }
    return {
        name: getTypeName(node),
        tag: getNodeTag(node)
    };
}
exports.activeNodeName = activeNodeName;
/**
 * @hidden
 */
function getNodeTag(node) {
    var parseRules = node.type.spec.parseDOM;
    var nodeAttrs = node.attrs;
    var parseRule;
    if (parseRules && parseRules.length) {
        if (parseRules.length === 1) {
            parseRule = parseRules[0];
        }
        else {
            parseRule = parseRules.find(function (rule) {
                //TODO: refactor this
                return JSON.stringify(rule.attrs) === JSON.stringify(nodeAttrs);
            });
        }
    }
    if (parseRule) {
        return parseRule.tag;
    }
}
/**
 * @hidden
 */
function canIndent(state, nodeType) {
    return isNodeActive(state, nodeType) && prosemirror_schema_list_1.sinkListItem(nodeType)(state);
}
exports.canIndent = canIndent;
/**
 * @hidden
 */
function canOutdent(state, nodeType) {
    var isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);
    var isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);
    return isNodeActive(state, nodeType) && (isNestedInOL || isNestedInUL) && prosemirror_schema_list_1.liftListItem(nodeType)(state);
}
exports.canOutdent = canOutdent;
/**
 * @hidden
 */
function findParentNode(predicate) {
    return function (selection) {
        var $from = selection.$from;
        for (var i = $from.depth; i > 0; i--) {
            var node = $from.node(i);
            if (predicate(node)) {
                return { depth: i, node: node };
            }
        }
    };
}
exports.findParentNode = findParentNode;
/**
 * @hidden
 */
function findNthParentNode(predicate, depth) {
    if (depth === void 0) { depth = 1; }
    return function (selection) {
        var $from = selection.$from;
        for (var i = $from.depth; i > 0; i--) {
            var node = $from.node(i);
            if (predicate(node)) {
                depth = depth - 1;
                if (depth === 0) {
                    return { depth: i, node: node };
                }
            }
        }
    };
}
exports.findNthParentNode = findNthParentNode;
/**
 * @hidden
 */
function findNthParentNodeOfType(nodeType, depth) {
    if (depth === void 0) { depth = 1; }
    return function (selection) {
        return findNthParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); }, depth)(selection);
    };
}
exports.findNthParentNodeOfType = findNthParentNodeOfType;
/**
 * @hidden
 */
exports.getMark = function (state, markType) {
    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
    var stateDoc = state.doc;
    var mark;
    if (empty) {
        mark = markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        stateDoc.nodesBetween(from, to, function (node) {
            if (node.isInline && !mark) {
                mark = markType.isInSet(node.marks);
            }
        });
    }
    return mark;
};
/**
 * @hidden
 */
exports.getNodeFromSelection = function (state) {
    if (state.selection instanceof prosemirror_state_1.NodeSelection) {
        return state.selection.node;
    }
};
/**
 * @hidden
 */
exports.getSelectionText = function (state) {
    var sel = state.selection;
    if (sel instanceof prosemirror_state_1.TextSelection || sel instanceof prosemirror_state_1.AllSelection) {
        var fragment = sel.content().content;
        return fragment.textBetween(0, fragment.size);
    }
    return '';
};
/**
 * @hidden
 */
exports.removeMark = function (markType) { return function (state, dispatch) {
    var _a = state.selection, from = _a.from, to = _a.to, $cursor = _a.$cursor;
    if ($cursor) {
        var resolvedRange = prosemirror_core_utils_1.getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
}; };
/**
 * @hidden
 */
exports.toggleBold = prosemirror_commands_1.toggleMark(schema_1.schema.marks.strong);
/**
 * @hidden
 */
exports.toggleItalic = prosemirror_commands_1.toggleMark(schema_1.schema.marks.em);
/**
 * @hidden
 */
exports.toggleUnderline = prosemirror_commands_1.toggleMark(schema_1.schema.marks.underline);
/**
 * @hidden
 */
exports.toggleStrikethrough = prosemirror_commands_1.toggleMark(schema_1.schema.marks.strikethrough);
/**
 * @hidden
 */
exports.toggleSubscript = prosemirror_commands_1.toggleMark(schema_1.schema.marks.subscript);
/**
 * @hidden
 */
exports.toggleSuperscript = prosemirror_commands_1.toggleMark(schema_1.schema.marks.superscript);
/**
 * @hidden
 */
exports.setFontFamily = function (font) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = prosemirror_core_utils_1.changeStyle(marks.style, {
        style: 'font-family', value: /^.+$/, newValue: font
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
exports.setFontSize = function (size) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = prosemirror_core_utils_1.changeStyle(marks.style, {
        style: 'font-size', value: /^.+$/, newValue: size + "px"
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
exports.createLink = function (attrs) { return function (state, dispatch) {
    if (isMarkActive(state, schema_1.schema.marks.link)) {
        prosemirror_core_utils_1.modifyMark(schema_1.schema.marks.link, attrs)(state, dispatch);
    }
    else if (state.selection.empty) {
        if (core_1.isDevMode() && !util_1.isPresent(attrs.text)) {
            throw new Error("Unable to create link without text.Please pass a 'text' property as part of the parameter or select any text in the Editor.");
        }
        var newLink = schema_1.schema.text(attrs.text, [
            schema_1.schema.marks.link.create(attrs)
        ].concat(exports.getActiveMarks(state).marks));
        dispatch(state.tr.replaceSelectionWith(newLink, false));
    }
    else {
        prosemirror_commands_1.toggleMark(schema_1.schema.marks.link, attrs)(state, dispatch);
    }
}; };
/**
 * @hidden
 */
exports.applyHeading = function (level) { return prosemirror_commands_1.setBlockType(heading, { level: level }); };
/**
 * @hidden
 */
exports.applyParagraph = prosemirror_commands_1.setBlockType(paragraph);
/**
 * @hidden
 */
exports.applyBlockquote = prosemirror_commands_1.setBlockType(blockquote);
/**
 * @hidden
 */
exports.format = function (_a) {
    var tag = _a.tag;
    if (tag.match(/h\d\b/)) {
        return exports.applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return exports.applyParagraph;
    }
    else if (tag === 'blockquote') {
        return exports.applyBlockquote;
    }
};
/**
 * @hidden
 */
exports.insertImage = function (attrs) { return function (state, dispatch) {
    var node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
}; };
/**
 * @hidden
 */
exports.getHTML = function (state) {
    var fragment = prosemirror_model_1.DOMSerializer
        .fromSchema(state.schema)
        .serializeFragment(state.doc.content);
    var element = document.createElement('div');
    element.appendChild(fragment);
    return element.innerHTML;
};
/**
 * @hidden
 */
exports.createContentNode = function (value) {
    var element = document.createElement('div');
    // when using ngModel with name attr, content is null and errors, default params dont help
    element.innerHTML = util_1.safeString(value).trim();
    return prosemirror_model_1.DOMParser.fromSchema(schema_1.schema).parse(element);
};
/**
 * @hidden
 */
exports.setHTML = function (content) { return function (state, dispatch) {
    return dispatch(state.tr
        .setSelection(new prosemirror_state_1.AllSelection(state.doc))
        .replaceSelectionWith(exports.createContentNode(content)));
}; };
/**
 * @hidden
 */
exports.hasSameMarkup = function (dom1, dom2) {
    var fragment1 = prosemirror_model_1.Fragment.from(exports.createContentNode(dom1));
    var fragment2 = prosemirror_model_1.Fragment.from(exports.createContentNode(dom2));
    return fragment1.eq(fragment2);
};
/**
 * @hidden
 * Checks if the selection contains a specific type of node.
 */
var hasNode = function (state, nodeType) {
    var _a = state.selection, from = _a.from, to = _a.to;
    var result = false;
    state.doc.nodesBetween(from, to, function (node) {
        result = result || node.type === nodeType;
        return !result;
    });
    return result;
};
/**
 * @hidden
 */
var blockNodes = function (state) {
    var selection = state.selection;
    var from = selection.from, to = selection.to, $from = selection.$from;
    var result = [];
    if (selection.node) {
        if (selection.node.isBlock) {
            result.push(selection.node);
        }
        else if ($from.parent && $from.parent.isBlock) {
            result.push($from.parent);
        }
    }
    else {
        state.doc.nodesBetween(from, to, function (node) {
            if (node.isBlock) {
                result.push(node);
            }
        });
    }
    return result;
};
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
exports.alignBlocks = function (actions) { return function (state, dispatch) {
    var blocks = blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = {};
            var action = actions.find(function (n) { return n.node === node.type.name; });
            if (action) {
                newAttrs = prosemirror_core_utils_1.addStyles(node, action.style);
            }
            result = prosemirror_core_utils_1.changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
/**
 * @hidden
 * Checks if any block element in the selection is aligned.
 */
exports.isAligned = function (state, actions) {
    var blocks = blockNodes(state);
    var result = false;
    blocks.forEach(function (node) {
        if (!result && node.type.isTextblock && node.attrs.style) {
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                result = action.style.every(function (style) {
                    return !!style.value && new RegExp(style.name + ":\\s?" + style.value, 'i').test(node.attrs.style);
                });
            }
        }
    });
    return result;
};
/**
 * @hidden
 * Indenting block elements in the selection.
 *
 * @returns {boolean} - Returns true if any indentation is applied.
 */
exports.indentBlocks = function (actions) { return function (state, dispatch) {
    var blocks = blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = void 0;
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                var newStyle = {
                    name: action.style,
                    value: action.step > 0 ? "" + action.step + action.unit : ''
                };
                if (node.attrs.style) {
                    var re = new RegExp(action.style + ":\\s?(\\d+)" + action.unit, 'i');
                    var match = node.attrs.style.match(re);
                    if (match) {
                        var newMargin = parseFloat(match[1]) + action.step;
                        newMargin = newMargin <= 0 ? '' : newMargin;
                        newStyle.value = "" + newMargin + (newMargin ? action.unit : '');
                    }
                }
                newAttrs = prosemirror_core_utils_1.addStyles(node, [newStyle]);
            }
            if (newAttrs) {
                result = prosemirror_core_utils_1.changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
            }
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
/**
 * @hidden
 * Checks if any block element in the selection is indented.
 */
exports.isIndented = function (state, actions) {
    var blocks = blockNodes(state);
    var result = false;
    blocks.forEach(function (node) {
        if (!result && node.type.isTextblock && node.attrs.style) {
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                var reIndent = new RegExp(action.style + ":\\s?\\d+" + action.unit, 'i');
                result = reIndent.test(node.attrs.style);
            }
        }
    });
    return result;
};
/**
 * @hidden
 */
exports.canIndentAsListItem = function (state) { return prosemirror_schema_list_1.sinkListItem(listItem)(state); };
/**
 * @hidden
 */
exports.canOutdentAsListItem = function (state) { return prosemirror_schema_list_1.liftListItem(listItem)(state); };
/**
 * @hidden
 */
exports.canBeIndented = function (state, rules) {
    var nodes = state.schema.nodes;
    return (exports.isIndented(state, rules) || indent_rules_1.indentRules.some(function (rule) { return nodes[rule.node] &&
        hasNode(state, nodes[rule.node]); })) && !hasNode(state, listItem);
};
/**
 * @hidden
 */
exports.indent = function (state, dispatch) {
    var isIndentableBlock = exports.canBeIndented(state, indent_rules_1.indentRules);
    if (exports.canIndentAsListItem(state)) {
        prosemirror_schema_list_1.sinkListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        exports.indentBlocks(indent_rules_1.indentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
exports.outdent = function (state, dispatch) {
    var isIndentableBlock = exports.canBeIndented(state, indent_rules_1.outdentRules);
    if (exports.canOutdentAsListItem(state)) {
        prosemirror_schema_list_1.liftListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        exports.indentBlocks(indent_rules_1.outdentRules)(state, dispatch);
    }
};
