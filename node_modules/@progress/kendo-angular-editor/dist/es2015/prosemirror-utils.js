import { isDevMode } from '@angular/core';
import { Node, DOMParser, DOMSerializer, Fragment } from 'prosemirror-model';
import { TextSelection, NodeSelection, AllSelection } from 'prosemirror-state';
import { toggleMark, setBlockType } from 'prosemirror-commands';
import { sinkListItem, liftListItem } from 'prosemirror-schema-list';
import { schema } from './config/schema';
import { safeString, first, last, unique, split, filter, trim, isPresent } from './util';
import { indentRules, outdentRules } from './config/indent-rules';
import { getMarkRange, modifyMark, addStyles, changeBlockNode, changeStyle } from './prosemirror-core-utils';
const { blockquote, bulletList, doc, heading, listItem, orderedList, paragraph, image } = schema.nodes;
const getTypeName = (n) => {
    return n instanceof Node ? n.type.name : n.name;
};
const isListType = (node) => {
    const nodeName = typeof node === 'string' ? node : getTypeName(node);
    return nodeName === getTypeName(orderedList) || nodeName === getTypeName(bulletList);
};
const getListTypeFromPos = (pos) => Array.from(new Array(pos.depth), (_, index) => pos.depth - index)
    .map((depth) => pos.node(depth))
    .map(getTypeName)
    .find(isListType);
const getNodeMarksOfType = (markType, n) => n.marks.filter(m => m.type.name === markType.name);
/**
 * @hidden
 */
export const getUniqueStyleValues = (style, cssStyle) => {
    if (style.hasNodesWithoutMarks) {
        return '';
    }
    const uniqueMarkValues = style.marks
        .filter(m => m.type.name === 'style')
        .map((m) => m.attrs.style)
        .map(split(';'))
        .map(filter((m) => m.includes(cssStyle)))
        .map((cssStyleValues) => (cssStyleValues.length !== 0 ? cssStyleValues : [`${cssStyle}: INVALID`]))
        .map(first)
        .map(split(':'))
        .map(last)
        .map(trim)
        .reduce((acc, curr) => (acc.indexOf(curr) > -1 ? acc : [...acc, curr]), []);
    if (uniqueMarkValues.indexOf('INVALID') > -1 || uniqueMarkValues.length !== 1) {
        return '';
    }
    return uniqueMarkValues[0];
};
/**
 * @hidden
 */
export function isMarkActive(state, markType) {
    const { from, $from, to, empty } = state.selection;
    if (empty) {
        return !!markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return !!state.doc.rangeHasMark(from, to, markType);
    }
}
/**
 * @hidden
 */
export function isNodeActive(state, nodeType, attrs) {
    const parent = findParentNode((node) => getTypeName(node) === getTypeName(nodeType))(state.selection);
    if (!parent || (attrs && !Object.keys(attrs).length)) {
        return !!parent;
    }
    return parent.node.hasMarkup(nodeType, attrs);
}
/**
 * @hidden
 */
export const isInListOfType = ({ selection }, nodeType) => {
    const { $anchor, $head } = selection;
    let topNodes = [];
    const anchorParentName = getListTypeFromPos($anchor);
    const headParentName = getListTypeFromPos($head);
    selection.content().content.descendants((n) => {
        topNodes = [...topNodes, n];
        return false;
    });
    const nonListTopNodes = topNodes.filter((n) => {
        return (getTypeName(n) !== getTypeName(bulletList)) && (getTypeName(n) !== getTypeName(orderedList));
    });
    // no selection
    if (selection instanceof TextSelection && selection.$cursor) {
        return getListTypeFromPos(selection.$cursor) === nodeType.name;
    }
    const hasSingleUniqueTopNode = unique(topNodes.map(getTypeName)).length === 1;
    // with selection
    if (nonListTopNodes.length > 0 || !hasSingleUniqueTopNode) {
        return false;
    }
    // from this point on we have guaranteed that the top nodes are all of the same LIST type
    // same top list node
    const node = first(topNodes);
    let listChildNodes = [getTypeName(node)];
    node.descendants((childNode) => {
        if (isListType(childNode)) {
            listChildNodes = [...listChildNodes, getTypeName(childNode)];
        }
    });
    if (last(listChildNodes) !== nodeType.name) {
        return false;
    }
    return anchorParentName === headParentName && anchorParentName === nodeType.name;
};
/**
 * @hidden
 */
export const getActiveMarks = ({ selection }, markType) => {
    let hasNodesWithoutMarks = false;
    if (selection instanceof TextSelection && selection.$cursor) {
        return {
            marks: selection.$cursor.marks().filter(m => markType ? m.type.name === markType.name : true),
            hasNodesWithoutMarks
        };
    }
    const filtered = [];
    selection.content().content.descendants((n) => {
        if (n.type.name === 'text') {
            const nodeMarksOfType = markType ? getNodeMarksOfType(markType, n) : n.marks;
            if (n.marks.length > 0 && nodeMarksOfType.length > 0) {
                filtered.push(...nodeMarksOfType);
            }
            else {
                hasNodesWithoutMarks = true;
            }
        }
    });
    return {
        marks: filtered,
        hasNodesWithoutMarks
    };
};
/**
 * @hidden
 */
export function activeNodeName(state) {
    let node;
    if (state.selection instanceof AllSelection) {
        node = state.doc;
    }
    else {
        const { $anchor } = state.selection;
        const blockNode = $anchor.node($anchor.blockRange().depth);
        const isDoc = getTypeName(blockNode) === getTypeName(doc);
        node = isDoc ? $anchor.node() : blockNode;
    }
    return {
        name: getTypeName(node),
        tag: getNodeTag(node)
    };
}
/**
 * @hidden
 */
function getNodeTag(node) {
    const parseRules = node.type.spec.parseDOM;
    const nodeAttrs = node.attrs;
    let parseRule;
    if (parseRules && parseRules.length) {
        if (parseRules.length === 1) {
            parseRule = parseRules[0];
        }
        else {
            parseRule = parseRules.find((rule) => {
                //TODO: refactor this
                return JSON.stringify(rule.attrs) === JSON.stringify(nodeAttrs);
            });
        }
    }
    if (parseRule) {
        return parseRule.tag;
    }
}
/**
 * @hidden
 */
export function canIndent(state, nodeType) {
    return isNodeActive(state, nodeType) && sinkListItem(nodeType)(state);
}
/**
 * @hidden
 */
export function canOutdent(state, nodeType) {
    const isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);
    const isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);
    return isNodeActive(state, nodeType) && (isNestedInOL || isNestedInUL) && liftListItem(nodeType)(state);
}
/**
 * @hidden
 */
export function findParentNode(predicate) {
    return function (selection) {
        const { $from } = selection;
        for (let i = $from.depth; i > 0; i--) {
            const node = $from.node(i);
            if (predicate(node)) {
                return { depth: i, node };
            }
        }
    };
}
/**
 * @hidden
 */
export function findNthParentNode(predicate, depth = 1) {
    return function (selection) {
        const { $from } = selection;
        for (let i = $from.depth; i > 0; i--) {
            const node = $from.node(i);
            if (predicate(node)) {
                depth = depth - 1;
                if (depth === 0) {
                    return { depth: i, node };
                }
            }
        }
    };
}
/**
 * @hidden
 */
export function findNthParentNodeOfType(nodeType, depth = 1) {
    return function (selection) {
        return findNthParentNode((node) => getTypeName(node) === getTypeName(nodeType), depth)(selection);
    };
}
/**
 * @hidden
 */
export const getMark = (state, markType) => {
    let { from, $from, to, empty } = state.selection;
    const stateDoc = state.doc;
    let mark;
    if (empty) {
        mark = markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        stateDoc.nodesBetween(from, to, node => {
            if (node.isInline && !mark) {
                mark = markType.isInSet(node.marks);
            }
        });
    }
    return mark;
};
/**
 * @hidden
 */
export const getNodeFromSelection = (state) => {
    if (state.selection instanceof NodeSelection) {
        return state.selection.node;
    }
};
/**
 * @hidden
 */
export const getSelectionText = (state) => {
    const sel = state.selection;
    if (sel instanceof TextSelection || sel instanceof AllSelection) {
        const fragment = sel.content().content;
        return fragment.textBetween(0, fragment.size);
    }
    return '';
};
/**
 * @hidden
 */
export const removeMark = (markType) => (state, dispatch) => {
    const { from, to, $cursor } = state.selection;
    if ($cursor) {
        let resolvedRange = getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
};
/**
 * @hidden
 */
export const toggleBold = toggleMark(schema.marks.strong);
/**
 * @hidden
 */
export const toggleItalic = toggleMark(schema.marks.em);
/**
 * @hidden
 */
export const toggleUnderline = toggleMark(schema.marks.underline);
/**
 * @hidden
 */
export const toggleStrikethrough = toggleMark(schema.marks.strikethrough);
/**
 * @hidden
 */
export const toggleSubscript = toggleMark(schema.marks.subscript);
/**
 * @hidden
 */
export const toggleSuperscript = toggleMark(schema.marks.superscript);
/**
 * @hidden
 */
export const setFontFamily = (font) => (state, dispatch) => {
    const marks = state.schema.marks;
    const cmd = changeStyle(marks.style, {
        style: 'font-family', value: /^.+$/, newValue: font
    });
    return cmd(state, dispatch);
};
/**
 * @hidden
 */
export const setFontSize = (size) => (state, dispatch) => {
    const marks = state.schema.marks;
    const cmd = changeStyle(marks.style, {
        style: 'font-size', value: /^.+$/, newValue: `${size}px`
    });
    return cmd(state, dispatch);
};
/**
 * @hidden
 */
export const createLink = (attrs) => (state, dispatch) => {
    if (isMarkActive(state, schema.marks.link)) {
        modifyMark(schema.marks.link, attrs)(state, dispatch);
    }
    else if (state.selection.empty) {
        if (isDevMode() && !isPresent(attrs.text)) {
            throw new Error("Unable to create link without text.Please pass a 'text' property as part of the parameter or select any text in the Editor.");
        }
        const newLink = schema.text(attrs.text, [
            schema.marks.link.create(attrs),
            ...getActiveMarks(state).marks
        ]);
        dispatch(state.tr.replaceSelectionWith(newLink, false));
    }
    else {
        toggleMark(schema.marks.link, attrs)(state, dispatch);
    }
};
/**
 * @hidden
 */
export const applyHeading = (level) => setBlockType(heading, { level });
/**
 * @hidden
 */
export const applyParagraph = setBlockType(paragraph);
/**
 * @hidden
 */
export const applyBlockquote = setBlockType(blockquote);
/**
 * @hidden
 */
export const format = ({ tag }) => {
    if (tag.match(/h\d\b/)) {
        return applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return applyParagraph;
    }
    else if (tag === 'blockquote') {
        return applyBlockquote;
    }
};
/**
 * @hidden
 */
export const insertImage = (attrs) => (state, dispatch) => {
    const node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
};
/**
 * @hidden
 */
export const getHTML = (state) => {
    const fragment = DOMSerializer
        .fromSchema(state.schema)
        .serializeFragment(state.doc.content);
    const element = document.createElement('div');
    element.appendChild(fragment);
    return element.innerHTML;
};
/**
 * @hidden
 */
export const createContentNode = (value) => {
    const element = document.createElement('div');
    // when using ngModel with name attr, content is null and errors, default params dont help
    element.innerHTML = safeString(value).trim();
    return DOMParser.fromSchema(schema).parse(element);
};
/**
 * @hidden
 */
export const setHTML = (content) => (state, dispatch) => dispatch(state.tr
    .setSelection(new AllSelection(state.doc))
    .replaceSelectionWith(createContentNode(content)));
/**
 * @hidden
 */
export const hasSameMarkup = (dom1, dom2) => {
    const fragment1 = Fragment.from(createContentNode(dom1));
    const fragment2 = Fragment.from(createContentNode(dom2));
    return fragment1.eq(fragment2);
};
/**
 * @hidden
 * Checks if the selection contains a specific type of node.
 */
const hasNode = (state, nodeType) => {
    let { from, to } = state.selection;
    let result = false;
    state.doc.nodesBetween(from, to, node => {
        result = result || node.type === nodeType;
        return !result;
    });
    return result;
};
/**
 * @hidden
 */
const blockNodes = (state) => {
    const selection = state.selection;
    let { from, to, $from } = selection;
    const result = [];
    if (selection.node) {
        if (selection.node.isBlock) {
            result.push(selection.node);
        }
        else if ($from.parent && $from.parent.isBlock) {
            result.push($from.parent);
        }
    }
    else {
        state.doc.nodesBetween(from, to, node => {
            if (node.isBlock) {
                result.push(node);
            }
        });
    }
    return result;
};
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
export const alignBlocks = (actions) => (state, dispatch) => {
    const blocks = blockNodes(state);
    const tr = state.tr;
    let result = false;
    blocks.forEach(node => {
        if (node.type.isTextblock) {
            let newAttrs = {};
            const action = actions.find(n => n.node === node.type.name);
            if (action) {
                newAttrs = addStyles(node, action.style);
            }
            result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
};
/**
 * @hidden
 * Checks if any block element in the selection is aligned.
 */
export const isAligned = (state, actions) => {
    const blocks = blockNodes(state);
    let result = false;
    blocks.forEach(node => {
        if (!result && node.type.isTextblock && node.attrs.style) {
            const action = actions.find(a => a.node === node.type.name);
            if (action) {
                result = action.style.every(style => {
                    return !!style.value && new RegExp(`${style.name}:\\s?${style.value}`, 'i').test(node.attrs.style);
                });
            }
        }
    });
    return result;
};
/**
 * @hidden
 * Indenting block elements in the selection.
 *
 * @returns {boolean} - Returns true if any indentation is applied.
 */
export const indentBlocks = (actions) => (state, dispatch) => {
    const blocks = blockNodes(state);
    const tr = state.tr;
    let result = false;
    blocks.forEach(node => {
        if (node.type.isTextblock) {
            let newAttrs;
            const action = actions.find(a => a.node === node.type.name);
            if (action) {
                const newStyle = {
                    name: action.style,
                    value: action.step > 0 ? `${action.step}${action.unit}` : ''
                };
                if (node.attrs.style) {
                    const re = new RegExp(`${action.style}:\\s?(\\d+)${action.unit}`, 'i');
                    const match = node.attrs.style.match(re);
                    if (match) {
                        let newMargin = parseFloat(match[1]) + action.step;
                        newMargin = newMargin <= 0 ? '' : newMargin;
                        newStyle.value = `${newMargin}${newMargin ? action.unit : ''}`;
                    }
                }
                newAttrs = addStyles(node, [newStyle]);
            }
            if (newAttrs) {
                result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
            }
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
};
/**
 * @hidden
 * Checks if any block element in the selection is indented.
 */
export const isIndented = (state, actions) => {
    const blocks = blockNodes(state);
    let result = false;
    blocks.forEach(node => {
        if (!result && node.type.isTextblock && node.attrs.style) {
            const action = actions.find(a => a.node === node.type.name);
            if (action) {
                const reIndent = new RegExp(`${action.style}:\\s?\\d+${action.unit}`, 'i');
                result = reIndent.test(node.attrs.style);
            }
        }
    });
    return result;
};
/**
 * @hidden
 */
export const canIndentAsListItem = (state) => sinkListItem(listItem)(state);
/**
 * @hidden
 */
export const canOutdentAsListItem = (state) => liftListItem(listItem)(state);
/**
 * @hidden
 */
export const canBeIndented = (state, rules) => {
    const nodes = state.schema.nodes;
    return (isIndented(state, rules) || indentRules.some(rule => nodes[rule.node] &&
        hasNode(state, nodes[rule.node]))) && !hasNode(state, listItem);
};
/**
 * @hidden
 */
export const indent = (state, dispatch) => {
    const isIndentableBlock = canBeIndented(state, indentRules);
    if (canIndentAsListItem(state)) {
        sinkListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(indentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
export const outdent = (state, dispatch) => {
    const isIndentableBlock = canBeIndented(state, outdentRules);
    if (canOutdentAsListItem(state)) {
        liftListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(outdentRules)(state, dispatch);
    }
};
